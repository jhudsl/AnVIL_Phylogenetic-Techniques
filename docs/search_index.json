[["index.html", "Molecular Phylogenetic Techniques About this Book AnVIL Collection", " Molecular Phylogenetic Techniques June 20, 2022 About this Book This book is part of a series of books for the Genomic Data Science Analysis, Visualization, and Informatics Lab-space (AnVIL) of the National Human Genome Research Institute (NHGRI). Learn more about AnVIL by visiting https://anvilproject.org or reading the preprint. AnVIL Collection Please check out our full collection of AnVIL and related resources below! Book Name Link AnVIL: Getting Started https://jhudatascience.org/AnVIL_Book_Getting_Started AnVIL: Instructor Guide https://jhudatascience.org/AnVIL_Book_Instructor_Guide AnVIL: WDL https://jhudatascience.org/AnVIL_Book_WDL GDSCN: SARS Galaxy on AnVIL https://jhudatascience.org/GDSCN_Book_SARS_Galaxy_on_AnVIL GDSCN: Statistics for Genomics Differential Expression https://jhudatascience.org/GDSCN_Book_Statistics_for_Genomics_Differential_Expression GDSCN: Statistics for Genomics PCA https://jhudatascience.org/GDSCN_Book_Statistics_for_Genomics_PCA GDSCN: Statistics for Genomics RNA-seq https://jhudatascience.org/GDSCN_Book_Statistics_for_Genomics_RNA-seq GDSCN: Statistics for Genomics scRNA-seq https://jhudatascience.org/GDSCN_Book_Statistics_for_Genomics_scRNA-seq "],["introduction.html", "Chapter 1 Introduction 1.1 Motivation 1.2 Target Audience 1.3 Curriculum", " Chapter 1 Introduction This book offers an introduction to molecular phylogenetic analyses using RStudio on AnVIL. Students will learn how to choose sequences for analysis, alignment, and the major methods of tree inference, as well as how to create useful phylogenetic tree figures. 1.1 Motivation Coming soon! 1.2 Target Audience The course is intended for advanced undergraduates with an understanding of evolutionary biology, or for graduate students. Experience with R is not necessary but is helpful. 1.3 Curriculum Coming soon! "],["sign-in.html", "Chapter 2 Sign in", " Chapter 2 Sign in You need to sign into Terra with your Google account to allow your instructor to add you to projects and/or Workspaces associated with your specific class. This is the only way you can launch applications and perform computations on AnVIL. You can access Terra by going to anvil.terra.bio, or by clicking the link on the AnVIL home page. Sign in using the drop-down menu in the upper-left-hand corner. "],["create-a-workspace.html", "Chapter 3 Create a workspace", " Chapter 3 Create a workspace On AnVIL, you use Workspaces to configure and run analyses and share results. Workspaces support interactive analysis with RStudio, Jupyter notebooks, Bioconductor and Galaxy. Workspaces can also save the output generated by running an analysis with a Workspace’s associated “cloud environment.” Check out https://anvilproject.org to learn more about everything you can do within a Workspace. In the drop-down menu on the left, navigate to “Workspaces”. Click the triple bar in the top left corner to access the menu. Click “Workspaces”. Click on the plus icon near the top of left of the page. Name your Workspace and select the Billing Project as indicated by your instructor. Do not change the Bucket Location or Authorization Domain. You can add a Description if you wish. Click “CREATE WORKSPACE”. The new Workspace should now show up under your Workspaces. "],["rstudio.html", "Chapter 4 Working in RStudio 4.1 Launch RStudio Cloud Environment 4.2 Tour RStudio 4.3 Pause RStudio 4.4 Delete RStudio Cloud Environment 4.5 Video Guide", " Chapter 4 Working in RStudio Once you have created a Workspace, you can create an RStudio cloud environment. This will allow you to interface with data and perform genomics-based analyses with add on packages from the Bioconductor community. 4.1 Launch RStudio Cloud Environment Click on the name of the Workspace you just created. You should be routed to a link that looks like: https://anvil.terra.bio/#workspaces/&lt;billing-project&gt;/&lt;workspace-name&gt;. On the top right, Click the gear icon to access your Cloud Environment options. You will see a list of costs because it costs a small amount of money to use cloud computing. Click “CUSTOMIZE”. Click on the first drop down menu to see what other software configurations are available. Scroll down and select RStudio from the Community-Maintained RStudio Environments section. NOTE: AnVIL is very versatile and can scale up to use very powerful cloud computers. It’s very important that you select the cloud computing environment described here to avoid runaway costs. Leave everything else as-is. To create your RStudio Cloud Environment, click on the “CREATE” button. Your Cloud Environment will be available in a few minutes after the cloud resources are provisioned and your software starts up. The upper right corner displays the status and should say “Creating” while resources are being provisioned. After a few minutes, you will see the status change to “Running”. Click on the “R” icon to launch RStudio. You should now see the RStudio interface with information about the version printed to the console. 4.2 Tour RStudio Next, we will be using RStudio and the package Glimma to create interactive plots. See this vignette for more information. The Bioconductor team has created a very useful package to programmatically interact with Terra and Google Cloud. Install the AnVIL package. It will make some steps easier as we go along. BiocManager::install(&quot;AnVIL&quot;) You can now quickly install precompiled binaries using the AnVIL package’s install() function. We will use it to install the Glimma package and the airway package. The airway package contains a SummarizedExperiment data class. This data describes an RNA-Seq experiment on four human airway smooth muscle cell lines treated with dexamethasone. {Note: for some of the packages in this class, you will have to install packaged from the CRAN repository, using the install.packages() function. The examples will show you which install method to use.} ```r AnVIL::install(c(&quot;Glimma&quot;, &quot;airway&quot;)) ``` &lt;img src=&quot;resources/images/02-rstudio_files/figure-html//1BLTCaogA04bbeSD1tR1Wt-mVceQA6FHXa8FmFzIARrg_g11f12bc99af_0_56.png&quot; title=&quot;Screenshot of the RStudio environment interface. Code has been typed in the console and is highlighted.&quot; alt=&quot;Screenshot of the RStudio environment interface. Code has been typed in the console and is highlighted.&quot; width=&quot;480&quot; /&gt; Load the example data. library(airway) data(airway) The multidimensional scaling (MDS) plot is frequently used to explore differences in samples. When this data is MDS transformed, the first two dimensions explain the greatest variance between samples, and the amount of variance decreases monotonically with increasing dimension. The following code will launch a new window where you can interact with the MDS plot. Glimma::glimmaMDS(assay(airway), group = colData(airway)$dex) Change the colour_by setting to “groups” so you can easily distinguish between groups. In this data, the “group” is the treatment. You can download the interactive html file by clicking on “Save As”. You can also download plots and other files created directly in RStudio. To download the following plot, click on “Export” and save in your preferred format to the default directory. This saves the file in your cloud environment. limma::plotMDS(airway) You should see the plot in the “Files” pane. Select this file and click “More” &gt; “Export” Select “Download” to save the file to your local machine. 4.3 Pause RStudio The upper right corner reminds you that you are accruing cloud computing costs. You should minimize charges when you are not performing an analysis. You can do this by clicking on “Stop cloud environment”. This will release the CPU and memory resources for other people to use. Note that your work will be saved in the environment and continue to accrue a very small cost. Your instructor can delete these environments to stop costs accruing, so it’s a good idea to save code or output somewhere else, such as GitHub or your local machine. 4.4 Delete RStudio Cloud Environment Stopping your cloud environment only pauses your work. When you are ready to delete the cloud environment, click on the gear icon in the upper right corner to “Update cloud environment”. Click on “Delete Environment Options”. If you are certain that you do not need the data and configuration on your disk, you should select “Delete everything, including persistent disk”. Select “DELETE”. 4.5 Video Guide In addition to the steps above, you can review this video guide on how to launch RStudio on AnVIL. The slides for this tutorial are are located here. sessionInfo() ## R version 4.0.2 (2020-06-22) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.3 LTS ## ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] knitr_1.33 magrittr_2.0.2 hms_0.5.3 R6_2.4.1 ## [5] rlang_0.4.10 highr_0.8 stringr_1.4.0 httr_1.4.2 ## [9] tools_4.0.2 xfun_0.26 png_0.1-7 jquerylib_0.1.4 ## [13] htmltools_0.5.0 ellipsis_0.3.1 ottrpal_0.1.2 yaml_2.2.1 ## [17] digest_0.6.25 tibble_3.0.3 lifecycle_1.0.0 crayon_1.3.4 ## [21] bookdown_0.24 readr_1.4.0 vctrs_0.3.4 fs_1.5.0 ## [25] curl_4.3 evaluate_0.14 rmarkdown_2.10 stringi_1.5.3 ## [29] compiler_4.0.2 pillar_1.4.6 pkgconfig_2.0.3 "],["phylogenetics-basics.html", "Chapter 5 Phylogenetics basics 5.1 How to read a phylogenetic tree 5.2 Outgroups 5.3 Branch lengths", " Chapter 5 Phylogenetics basics 5.1 How to read a phylogenetic tree A phylogeny, or phylogenetic tree, is a diagram that shows the evolutionary history and relationships among or within groups of organisms. Phylogenetics was traditionally a somewhat obscure field in which systematists (biologists concerned with arranging organisms into a tree that showed their ancestral relatedness) arranged related living organisms at the tips (or “leaves” of the tree), and made branches to connect different organisms back to putative ancestral organisms. Here’s a phylogeny of the family Ursidae (the bears). In this tree, all the extant species (or currently living species) are at the tips on the far right side of the phylogeny. Inferences about how the bear species are related become apparent as you move away from the tips down the branches. When two branches meet at a node (as they do at point A), you can assume the species at the tips of those branches share a common ancestor. For example, this phylogeny of the Ursidae indicates that American black bears and Asian black bears share a common ancestor (indicated by the node at point A). However, we don’t know what the common ancestor is for certain, we are just inferring based on similarities between the species that exist today. Nodes that are closer to the tips indicate species that are more closely related (and thus indicate a more recent common ancestor than nodes farther away from the tips). American black bears are more closely related to Asian black bears than to American black bears are to giant pandas, because the American black bear branch connects to a node shared by the Asian black bear branch (point A) before it connects to a node shared with the giant panda branch (point B). Another unusual thing about phylogenies is we can change the order of the taxa on the tips without actually changing the topology of the tree. These two trees are the same, even though we have changed the position of the labels of American black bear and Asian black bear. In phylogenetic trees, relatedness is expressed by the distance to a common node between two species, NOT by whether the labels are near each other. Branches can rotate freely around nodes without changing the tree. 5.2 Outgroups Although this is a phylogeny of the Ursidae, you might have noticed there are two branches belonging to the gray wolf and the spotted seal, neither of which is a bear. These two species are included as outgroups. Outgroups are taxa that are only distantly related to the group of interest and serve as reference points for determining evolutionary changes. 5.3 Branch lengths Branch lengths (the distance between two nodes, or between a node and a tip), may or may not be indicative of the passage of a particular amount of time. It depends on how the tree was inferred (we infer phylogenetic trees, we don’t make them). If the tree is created by parsimony or neighbor-joining methods, the branches simply indicate that there was one (or more) change from the ancestor to the descendant. If the tree was created using maximum likelihood methods, the branch lengths represent how many genetic changes occurred over time. Regardless of how the trees are constructed, they are estimates of what we think happened historically. Each estimate contains within it implicit assumptions about rates of mutation accumulating, likelihood of different types of changes being more common (transitions vs. transversions, for example), and so on. The tree is our best hypothesis as to the history of the organisms on it, but it is only a hypothesis. At one time, only morphological data could be used to make these trees. Thus, phylogenetic trees might have been based on similarities of bone structures, or fur types, or other gross physiological features. Even though the trees were called “phylogenetic” trees, they were not based on genetic data. Now, phylogenetic trees are generally based on DNA sequence (for closely related species) or amino acid sequences (for more distantly related species). Furthermore, the trees are generally based on several genetic loci, rather than on the whole genome. This is changing, with next generation sequencing and advances in computing power. Nevertheless, at present most phylogenetic trees are “gene trees” rather than “species trees,” and it is important to remember that selection or drift on a particular locus can influence a tree so that it reflects the history of the gene, but NOT the history of the species "],["visualizing-trees-in-r.html", "Chapter 6 Visualizing trees in R 6.1 Creating a Newick object 6.2 Drawing trees 6.3 Adding outgroups 6.4 Drawing trees multiple ways 6.5 The phylo class", " Chapter 6 Visualizing trees in R 6.1 Creating a Newick object Computer programs use the Newick tree format for phylogenetic trees. This format uses a series of parentheses, commas, and colons to store information about evolutionary relationships. (A,B) indicates a pair of taxa that form their own group, or clade ((A,B),C) indicates the next most closely related taxon to the A-B clade is taxon C (A:5,B:7) tells the program (and us!) the length of the branch connecting each taxon to the node. In this case, the branch length between the node and A is 5 and the branch length for B is 7. The total distance between A and B is 5+7, or 12. ((A,B),C)); tells the program the tree is complete. If the semicolon is missing at the end, the program will keep looking for information on another taxon. For this exercise, we are going to create an R object in Newick formula that illustrates the relationships among several species of mammals. #install.packages(&#39;ape&#39;) #this installs the ape package #install.packages(&#39;nlme&#39;) #this installs the nlme package library(ape) #this opens the ape package library(nlme) #this opens the nlme package #we first create an object that stores the tree information mammal.1 &lt;- read.tree(text = &quot;((((raccoon:19.19959,bear:6.80041):0.84600, weasel:18.87953):2.09460):3.87382,dog:25.46154);&quot;) #typing the name of the object means R will tell us about it mammal.1 ## ## Phylogenetic tree with 4 tips and 4 internal nodes. ## ## Tip labels: ## raccoon, bear, ## weasel, dog ## ## Rooted; includes branch lengths. We now have a phylogenetic tree loaded into R. Why is it called Newick format? This is what Joe Felsenstein, one of the giants of the phylogenetic field, says: “The Newick Standard was adopted 26 June 1986 by an informal committee meeting convened by me during the Society for the Study of Evolution meetings in Durham, New Hampshire and consisting of James Archie, William H.E. Day, Wayne Maddison, Christopher Meacham, F. James Rohlf, David Swofford, and myself. (The committee was not an activity of the SSE nor endorsed by it). The reason for the name is that the second and final session of the committee met at Newick’s restaurant in Dover, New Hampshire, and we enjoyed the meal of lobsters. The tree representation was a generalization of one developed by Christopher Meacham in 1984 for the tree plotting programs that he wrote for the PHYLIP package while visiting Seattle. His visit was a sabbatical leave from the University of Georgia, which thus indirectly partly funded that work.” 6.2 Drawing trees It is quite difficult for humans to quickly interpret the relationships and branch lengths in the Newick format. Luckily, R (and other phylogenetics programs) can convert Newick formats into a more understandable form. #plot is the command we use to create trees with the ape package #one of the options is the type of tree the command draws #this can also be written as plot(mammal.1, &quot;u&quot;) plot(mammal.1, type=&quot;unrooted&quot;) You’ve inferred an unrooted tree. It probably looks a bit different than trees you’ve seen before (including the one in the previous section); most trees are displayed in a rooted form. We can do that by specifying that we want to draw a phylogram. If you don’t declare an outgroup first, R will choose to root the phylogram halfway between the two longest branches (this is called midpoint rooting). #here we draw a phylogram #alternatively, you can use the command: #plot(plot(mammal.1), as phylogram is the default type plot(mammal.1, type=&quot;phylogram&quot;) Now the tree looks more like the Ursidae tree we examined earlier. The order of the tips is partly determined by the order in which we wrote the taxa in our Newick format. We can change the order of the tips and still have the same tree. mammal.2 &lt;- read.tree(text = &quot;((((bear:6.80041,raccoon:19.19959):0.84600, weasel:18.87953):2.09460):3.87382,dog:25.46154);&quot;) #this bit of code here tells R to put the trees in side-by-side in #a single row (1 row, 2 columns) par(mfrow=c(1,2)) plot(mammal.1) plot(mammal.2) Clades can rotate freely around nodes without changing the relationships among the tips. Although the “weasel” label is closer to “bear” in our first tree than it is in the second tree, the evolutionary distance between the two is the same in both trees, because we trace through the same nodes to find their common ancestor. Both of these trees are exactly the same, in a phylogenetic sense. 6.3 Adding outgroups Let’s add some more taxa to our tree! mammal.3 &lt;- read.tree(text = &quot;((raccoon:19.19959,bear:6.80041):0.84600,((sea_lion:11.99700, seal:12.00300):7.52973,((monkey:100.85930,cat:47.14069):20.59201, weasel:18.87953):2.09460):3.87382,dog:25.46154);&quot;) mammal.3 ## ## Phylogenetic tree with 8 tips and 6 internal nodes. ## ## Tip labels: ## raccoon, bear, sea_lion, ## seal, monkey, cat, ... ## ## Unrooted; includes branch lengths. We’ve now added an additional 5 taxa to our tree of mammalian species. Let’s first take a look at the unrooted tree. plot(mammal.3, type=&quot;u&quot;)#&quot;u&quot; is short for &quot;unrooted&quot; Even with the unrooted tree, we can see that some species are definitely more closely related than others. In fact, it looks like both “cat” and “monkey” are pretty distantly related to the others, since the branches connecting these taxa are much longer than any other branch. Given this information, we will define these two taxa as our outgroup and redraw our tree, this time as a rooted phylogram. #this command tells R that monkey and cat are outgroups mammal.3.root &lt;- root(mammal.3, outgroup = c(&#39;monkey&#39;,&#39;cat&#39;)) plot(mammal.3.root, type=&quot;p&quot;)#&quot;p&quot; is short for &quot;phylogram&quot; 6.4 Drawing trees multiple ways So far you’ve drawn trees in two ways - unrooted, and as a phylogram. For both of these tree types, the branch lengths are scaled to indicate evolutionary distance (or how many changes have occurred). As a result, the tips aren’t all even with each other. There are two other common ways of drawing trees. The radial tree (sometimes called the fan tree) arranges all the branches in a circle. This is a popular way to draw a phylogeny with many tips that would otherwise take up a lot of space. #now we&#39;re looking at three different trees next to each other #basically, figures are in 1 row and 3 columns par(mfrow=c(1,3)) plot(mammal.3, type=&quot;u&quot;) plot(mammal.3.root, type=&quot;p&quot;) plot(mammal.3.root, type=&quot;f&quot;)#f is short for &quot;fan&quot; All three of these trees show exactly the same information. The last common way to draw trees is as a cladogram. Cladograms are a little different than the others, because the branches are not scaled to evolutionary distance. Instead, the tree is drawn so that all the tips (taxa) are lined up. It is often easier to see relationships in a cladogram, particularly if the internode distances (the distance between two internal nodes of a tree) are small. To properly draw a cladogram, we will rewrite our tree in Newick formula so that it doesn’t include branch lengths. mammal.4 &lt;- read.tree(text = &quot;(dog,(raccoon,bear),((seal,sea_lion), ((monkey,cat), weasel)));&quot;) mammal.4.root &lt;- root(mammal.4, outgroup = c(&#39;monkey&#39;,&#39;cat&#39;)) par(mfrow=c(1,2)) plot(mammal.3.root, type=&quot;p&quot;) plot(mammal.4.root, type=&quot;c&quot;)#c is short for &quot;cladogram&quot; QUESTIONS What is the total branch length between “bear” and “raccoon”? (You will need to look at the tree in Newick format.) Does “weasel” share a more common recent ancestor with “seal” or with “sea lion”? Why does it look like “weasel” is more closely related to “bear” in the tree with four taxa, but it looks like “dog” is more closely related to “bear” in the tree with eight taxa? (HINT: Think about the purpose of an outgroup, and whether we specified one for the four-taxa tree.) 6.5 The phylo class When we use the ape package, R converts a tree in Newick format to an object of the phylo class. This is basically a list of four dataframes. str(mammal.3.root) ## List of 4 ## $ edge : int [1:13, 1:2] 9 14 12 10 11 11 10 12 13 13 ... ## $ edge.length: num [1:13] 20.592 2.095 3.874 0.846 19.2 ... ## $ Nnode : int 6 ## $ tip.label : chr [1:8] &quot;raccoon&quot; &quot;bear&quot; &quot;sea_lion&quot; &quot;\\nseal&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Each dataframe holds information about some part of the tree. edge: the number of steps needed to connect two tips. It’s easiest to think of each branch as an edge. edge.length: the length of each corresponding edge, or branch Nnode: the number of nodes in the tree tip.label: the tip names (the taxa) sessionInfo() ## R version 4.0.2 (2020-06-22) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.3 LTS ## ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] nlme_3.1-149 ape_5.4-1 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.8 knitr_1.33 magrittr_2.0.2 hms_0.5.3 ## [5] lattice_0.20-41 R6_2.4.1 rlang_0.4.10 highr_0.8 ## [9] stringr_1.4.0 tools_4.0.2 parallel_4.0.2 grid_4.0.2 ## [13] xfun_0.26 jquerylib_0.1.4 htmltools_0.5.0 ellipsis_0.3.1 ## [17] ottrpal_0.1.2 yaml_2.2.1 digest_0.6.25 tibble_3.0.3 ## [21] lifecycle_1.0.0 crayon_1.3.4 bookdown_0.24 readr_1.4.0 ## [25] vctrs_0.3.4 fs_1.5.0 evaluate_0.14 rmarkdown_2.10 ## [29] stringi_1.5.3 compiler_4.0.2 pillar_1.4.6 pkgconfig_2.0.3 "],["what-sequences-should-i-choose.html", "Chapter 7 What sequences should I choose?", " Chapter 7 What sequences should I choose? Phylogenies are only as good as the data used to infer them, so it’s worth it to the spend some time carefully choosing the genomic regions and samples you will use. Good planning from the beginning will save you headaches further downstream. First, you should ask yourself: what information are you hoping to gain from the tree? Are you hoping to reconstruct the history of organisms, or the history of a region of DNA, or the history of a protein? The answer will guide your choice of sequence and samples. For closely related species in which you might hope to figure out some sort of information about the divergence between the species (including the timing of the divergence), you would use areas of the genome known to accumulate changes rapidly (non-coding regions that also do not have functionality, or whose functionality is not easily changed by changes in the DNA base sequence). Some examples of rapidly changing genetic regions include the mitochondrial control region, the wobble base on mitochondrial coding regions, and nuclear introns. It is also important to use “dense taxon sampling” among closely related species because any small change can seem disproportionately important in a recent divergence. Having multiple individuals sampled from each phylogenetic unit of interest (could be species, subspecies, or populations) helps to compensate by showing the genetic divergence within a group. This within-group divergence can then be accurately compared to the genetic divergence between two groups. For more divergent species and comparisons, you use areas of the genome that do not change as rapidly. For example, if you wanted to do a survey of the placental mammals, you could choose a gene region that is under enough selection pressure that it mutates more slowly than the regions you would choose for closely related species. If you are examining the relationships among deeply divergent species, or when the base-pair signal is completely swamped out over time, you might search for amino acid sequence similarities instead of DNA sequence similarities. Because of wobble, amino acid sequence can remain the same even when bases change. Sometimes amino acids of similar size/charge/shape can be substituted for others, which would result in a complete change in base pair sequence (and loss of ability to find similar sequences), but allows for finding similarities through amino acid sequence. Even when using protein sequence, it is often helpful to extract the coding sequence (once similar protein sequences have been found), because that adds extra information to fine tune the phylogenetic analysis. This technique can also be used when the primary goal is to trace the history of a particular gene (when the changes in the gene itself are of interest.) To attempt a reconstruction of the evolutionary history of organisms, you really should use multiple lines of evidence and not rely solely on genomic data. For example to reconstruct primate evolution, one looks at the fossil record, molecular divergence, and also phylogeographic evidence (how these things map onto our understanding of the geography of the earth at various crucial time points along primate evolution). Examples of phylogeographic evidence include understanding when terrestrial (land-based) organisms might have been cut off from each other due to the formation of a river or lake, the eradication of a land bridge by melting glaciers and a rise in the earth’s temperature (which raises the sea level). Alas, for this book, we are limited to only using genomic data. "],["finding-sequences-in-genbank.html", "Chapter 8 Finding sequences in GenBank 8.1 Identifying a query sequence on GenBank 8.2 blastn 8.3 Identifying an outgroup", " Chapter 8 Finding sequences in GenBank 8.1 Identifying a query sequence on GenBank For this book, we will use Glu-1 sequences from a variety of species to infer our tree. Glu-1 is a gene that encodes one of the subunits used to make gluten in plants like wheat. We will use this gene to reconstruct some of the deeper phylogenetic relationships among the grasses. We’re going to temporarily leave AnVIL and RStudio and head to NCBI’s website. We start by searching for Glu-1 sequences in the NCBI nucleotide database. At the top of the website, use the pulldown menu to choose “Nucleotide” and enter “glu-1” in the search bar. You might notice that this returns thousands upon thousands of possible sequences. While it’s nice having choices, having too many results makes it difficult to know where to start. Instead, we’re going to narrow down our sequence choices by specifying that we want Glu-1 sequences from common wheat, or Triticum aestivium. This is a good starting point, since we know that common wheat plants make the gluten protein, so the genome should contain Glu-1. The first hit (at least from when this guide was created) is exactly what we’re looking for - the complete coding sequence for the high molecular weight glutenin subunit, the Glu-1 gene. If we click on the link at the top of the entry, we can go to the GenBank page for this particular entry. This page contains a lot of information about the sequence, including which research group generated it, if the sequence was used in published research, and the full taxonomy of the sample. At the top, we also find the accession number, or the unique ID assigned to this particular sequence. Highlight and copy the accession number - this is what we will use for our next step, a BLAST search. 8.2 blastn NCBI created a tool that allows us to use the basic local alignment search tool (BLAST) algorithm to find sequences similar to our query sequence (in this case, the Triticum aestivium sequence we identified above). Here’s a link for NCBI’s web tool: BLAST. There are many tutorials on how to use BLAST (including NCBI’s own), so this section is going to focus primarily on the logic behind choosing sequences for phylogenetic analysis, not just the steps. Once you open the BLAST webpage, you have five options for searching (the tabs at the top of the page). Which method you choose depends on your query sequence. We’re going to work with two of them: blastn, which identifies DNA sequences that are most similar to the DNA (or nucleotide) query sequence; and blastp, which does the same for protein sequences. For the blastn search, all we need to do is paste the accession code from earlier into the search box and change our program selection to somewhat similar sequences (blastn). Next, let’s go down to the bottom of the page to the algorithm parameters section. We need to change the max number of target sequences (the maximum number of sequences for our search to return). Given how rapidly the size of the GenBank databases are growing, leaving this value at 100 means we will miss a lot of sequences that we might otherwise want to see. For now, we can leave the other parameters as the default settings. The click the BLAST button on the bottom left. It can take a couple of minutes for the blastn search to finish. When it does, a webpage similar to the figure above will open. On the right side of the screen, we have the option of applying additional filters to our search. Because we are interested in looking at the deeper phylogenetic relationships among the grass family, we don’t necessarily want any additional Triticum aestivium sequences, so we will filter them out. That leaves us with over 2,000 other sequences from which to choose our taxa. (If you were interested in more shallow phylogenetic relationships, choosing multiple sequences from the same taxa, or dense taxon sampling, is a good decision.) There are three quality-control statistics at which we want to look. query cover: the amount of overlap between our query sequence and the newly-aligned sequence; larger is better _E value_ (expect value): the number of hits expected by chance; like p-values, a lower number is better *per ident (percent identity): the percent similarity between the two sequences; larger is better We can filter or sort on any of these statistics. At this point we need to really look at the aligned sequences and decide which ones we want to use. There are quite a few samples from a variety of grass species that show good overlap, low E values, and high percent identities. Since we have options, we will prioritize choosing samples with complete coding sequence whenever possible (and avoid any sample labeled “pseudogene”, since that isn’t the actual Glu-1 gene sequence). We will focus on these 9 sequences (in addition to the common wheat sequence we identified earlier): EF105403.1, Thinopyrum intermedium (intermediate wheatgrass) DQ073553.1, Leymus racemosus (mammoth wild rye) EF204545.1, Lophopyrum elongatum (tall wheatgrass) AJ314771.1, Secale cereale (rye) FJ481569.1, Henrardia (a genus of Asiatic wheatgrass) DQ073533.1, Agropyron cristatum (crested wheatgrass) AY804128.1, Aegilops tauschii (Tausch’s goatgrass) AY303125.2, Taeniathetum caput (medusahead rye) KF887414.1, Dasypyrum villosum (mosquito grass) A quick check of the taxonomy confirms that all of these samples are from the grass family, family Poaceae. 8.3 Identifying an outgroup We have two approaches we could take for identifying an outgroup - we could use a more distantly related taxon, or we could use a homologous gene sequence from a more closely-related taxon. When we look up information about the Poaceae, we find there are three clades within the family - cereal grasses (like wheat), bamboos, and grasses (such as those species found in natural grasslands or cultivated for lawns and pastures). In the list of 10 related sequences above, we don’t have any sequences from the bamboos (subfamily Bambusoideae). Glu-1 from a bamboo species might make a nice outgroup, if we can find a sequence for it. First, we’ll try another blastn search, this time setting the program selection to more dissimilar sequences (discontiguous megablast) When we get those results back, we can filter for samples within the subfamily Bambusoideae. Alas, we have no sequences that match. The next thing we can try is a blastp search. These searches are nice for identifying more distantly related samples, because the protein sequence of a gene changes more slowly than the nucleotide sequence. In order to run a blastp search, we need a protein sequence for our query. Luckily, we chose a full coding sequence. When we look at the GenBank entry for JX915632, we can find the coding sequence translated into the amino acids at the bottom of the page. We can copy this amino acid sequence and paste it into the query box on the blastp page. After the blastp search finishes and we filter out Triticum aestivium results, we end up with several hundred matches. Great! …or is it? Unfortunately, all of the samples that are returned have very poor query coverage (less than 25%). None of these samples are likely to work for our purposes. Instead, we will have to try a homologous gene from a closely-related taxon. In our first blastn search, samples labeled “D-hordein” showed up near the bottom of the results. A Google search suggests that D-hordein is a barley homolog to the wheat Glu-1 gene product. This might serve nicely as an outgroup. We will add 2 additional sequences to our list, for a total of 11: D82941.1, Hordeum vulgare (barley) D-hordein JX276655.1, Elymus sibiricus (Siberian wild rye) D-hordein "],["downloading-the-sequences-from-genbank.html", "Chapter 9 Downloading the sequences from GenBank 9.1 The DNA.bin object 9.2 The fasta format", " Chapter 9 Downloading the sequences from GenBank Now that we have identified the sequences for our tree, we need to download those sequences from GenBank into R. One option is to download the sequences directly from GenBank as a fasta file. If you are interested in this option, here is a good tutorial on how to do it. This will work and the subsequent fasta file can be uploaded into R. 9.1 The DNA.bin object However, the library ape has a command that allows us to download sequences from GenBank directly into R and store the sequences as a DNA.bin object. This is a data structure that stores information like DNA sequence, how long each sequence is, information about the species identification of each sequence, and the total base percentages of all the sequences. The command we’re using is read.GenBank, which takes an argument of the accession number we want to download from GenBank. Since we want to download multiple sequences, We use c(““) to concatenate a string of accession numbers that read.Genbank will interpret. library(ape) #if you haven&#39;t previously loaded ape read.GenBank(c(&quot;JX915632&quot;,&quot;EF105403.1&quot;,&quot;DQ073553.1&quot;, &quot;FJ481575.1&quot;,&quot;EF204545.1&quot;,&quot;AJ314771.1&quot;,&quot;FJ481569.1&quot;, &quot;DQ073533.1&quot;,&quot;AY804128.1&quot;,&quot;AY303125.2&quot;,&quot;KF887414.1&quot;, &quot;D82941.1&quot;,&quot;JX276655.1&quot;)) ## 13 DNA sequences in binary format stored in a list. ## ## Mean sequence length: 1814.385 ## Shortest sequence: 1476 ## Longest sequence: 2490 ## ## Labels: ## JX915632 ## EF105403.1 ## DQ073553.1 ## FJ481575.1 ## EF204545.1 ## AJ314771.1 ## ... ## ## Base composition: ## a c g t ## 0.310 0.303 0.271 0.115 ## (Total: 23.59 kb) Now that you have seen what read.Genbank does, we will save it as an object, and also specify that we want the sequences in ATGC form. When as.character=TRUE is not included (like above), read.GenBank saves all the sequence data in a binary format. Binary is great for computers, but harder for humans to quickly interpret. grass &lt;- read.GenBank(c(&quot;JX915632&quot;,&quot;EF105403.1&quot;,&quot;DQ073553.1&quot;, &quot;FJ481575.1&quot;,&quot;EF204545.1&quot;,&quot;AJ314771.1&quot;,&quot;FJ481569.1&quot;, &quot;DQ073533.1&quot;,&quot;AY804128.1&quot;,&quot;AY303125.2&quot;,&quot;KF887414.1&quot;, &quot;D82941.1&quot;,&quot;JX276655.1&quot;)) R BASICS In R, you can do two things with the output of a command. First, you can have the output displayed immediately. This is what you did in the first block of R code above. This can be really helpful if you want to immediately see what your command did, but it’s less helpful if you want to do something with the output. In the first block of code, we managed to download sequences from GenBank and print them to the screen, but we don’t have a way to build trees from the printed screen. (Print in this case refers to the display you see on the R console.) Second, you can tell R to save the output as an object. This is what we did second block of code with grass &lt;- read.GenBank. The &lt;- operator tells R to redirect the output from read.GenBank to an object (or data structure) named grass. Everything you saw printed on the screen from the first block of code is now saved to grass. If we ever want to see what objects we have saved in our R session, we can do so by typing the command ls() This tells R to list objects. We can see what each object contains by either typing the name of the object or by using the str (structure) command. The syntax of the structure command is str(object_name) 9.2 The fasta format While ape and related R packages have no difficulty interpreting a DNA.bin object, other programs need the data in the fasta format. Fasta is a really common format for saving bioinformatic data (probably the most common format used!). The format itself is quite simple and consists of two lines. The first line is the header line, which starts with &gt;, immediately followed by a unique identifier. The sequence itself is on the second line. The sequence can either the standard IUPAC nucleic acid or amino acid codes, with additional characters for gaps (-), uracil (U), or translation stops (*). The first 60 nucleotides from the Triticum aestivium sequence from above might look like this in fasta format: JX915632_Triticum_aestivium atggctaagcggctggtcctctttgcagcagtagccgtcgccctcgtggctctcaccgcc We can convert and save our DNA.bin object in fasta format using a tool from the ape package. The write.dna commands takes three arguments: the first argument tells R the DNA.bin file to use, the second argument says what to name the new file, and the third argument says what format to use for the new file. write.dna( grass, file = &#39;grass.fasta&#39;, format = &#39;fasta&#39; ) If you check your RStudio files (on the lower left side of the screen, you’ll see a tab named Files), you should see a newly-created file called “grass.fasta”. If you open it up, the file will look something like this: Going forward, we will use both the DNA.bin object and the fasta file. R BASICS You might have noticed that we didn’t save the output of write.dna to an object. That’s because any of the write commands are automatically saving the output to a file on your computer (or, on AnVIL, to your persistent disk). The output is saved in what as known as your working directory. You can check what your current working directory is during any R session with the command getwd() sessionInfo() ## R version 4.0.2 (2020-06-22) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.3 LTS ## ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] ape_5.4-1 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.8 knitr_1.33 magrittr_2.0.2 hms_0.5.3 ## [5] lattice_0.20-41 R6_2.4.1 rlang_0.4.10 stringr_1.4.0 ## [9] tools_4.0.2 parallel_4.0.2 grid_4.0.2 nlme_3.1-149 ## [13] xfun_0.26 jquerylib_0.1.4 htmltools_0.5.0 ellipsis_0.3.1 ## [17] ottrpal_0.1.2 yaml_2.2.1 digest_0.6.25 tibble_3.0.3 ## [21] lifecycle_1.0.0 crayon_1.3.4 bookdown_0.24 readr_1.4.0 ## [25] vctrs_0.3.4 fs_1.5.0 evaluate_0.14 rmarkdown_2.10 ## [29] stringi_1.5.3 compiler_4.0.2 pillar_1.4.6 pkgconfig_2.0.3 "],["why-do-we-align-sequences.html", "Chapter 10 Why do we align sequences?", " Chapter 10 Why do we align sequences? Sequence alignment is the art of lining up sequences from different samples in such a way that that reflects shared quality. When we perform an alignment in preparation for phylogenetic analyses, we aim to line up our sequences so that the complete alignment reflects the evolutionary relationships among all the samples. When we look at it, this mean that long stretches of the sequences should be fairly similar, with smaller regions of dissimilarity scattered throughout. As the samples become more distantly related from each other, the regions of similarity will become smaller and the regions of dissimilarity will become larger. How the regions of dissimilarity are arranged can change, depending on our choices of assumptions. All alignment programs will assign a “price” to each potential alignment the create, then return the least costly alignment as the final result. Most programs create potential alignments using an algorithm that assigns similarity scores to each pairwise comparison. The program then uses these scores to determine the final potential alignment. The algorithm also assigns penalties for alignments that include undesireable features. In general, an alignment algorithm can apply two major costs: gap opening cost: we can apply a penalty for opening (or starting) any gap (indicating an insertion or deletion event) gap extension cost: we can apply a penalty for making a gap longer Alignments can be created using either the nucleotide sequence or the amino acid sequence. Amino acid sequences can be useful when dealing with more diverse samples where the nucleotide sequence includes lots of regions of dissimilarity and few regions of similarity. Because there are only 4 nucleotides, compared to 20 amino acids, amino acid sequence alignments tend to be less noisy than nucleotide sequence alignments. Amino acid sequences are also slower to change than nucleotide sequences due silent (or synonymous) nucleotide mutations that don’t affect the amino acid sequence. Keep in mind that any alignment we use is still just a hypothesis - it may be a well-supported hypothesis that represents our best knowledge, but it may still not be correct. We may never know what the “true” alignment is. "],["creating-a-multiple-sequence-alignment.html", "Chapter 11 Creating a multiple sequence alignment 11.1 Installing the DECIPHER package 11.2 Loading the fasta file 11.3 Creating an alignment", " Chapter 11 Creating a multiple sequence alignment There are several packages available now for performing alignments in R, include ape (which we have used before), Biostrings, and mas. Each of these have their own strengths, and all of them will produce a good alignment. There are also many non-R-based alignment programs. For this class, we will focus on how to use the DECIPHER package, which will allow us to create an alignment, as well as look at it. If you would like to learn more about DECIPHER, you can find the manuals and specific examples (vignettes) here, the the Documentation section. 11.1 Installing the DECIPHER package DECIPHER is available via Bioconductor, which means we can install it using the AnVIL::install command. After we install the package, we can then open it via the library() command. (If you are prompted to update dependent packages, choose “all”.) #AnVIL::install(&#39;DECIPHER&#39;) #use this command to install the DECIPHER package library(DECIPHER) 11.2 Loading the fasta file DECIPHER’s commands use a fasta file as their input. We could load the fasta file directly into one of the commands, or we could load the fasta file into an object that we then pass to the commands. The second option gives us more flexibility and ultimately ends up saving time - we can load the file once and use it for multiple calculations. We are loading the fasta object we created and saved in our working directory last time. If the fasta file isn’t in your working directory, that’s okay - you can replace “grass.fasta” with the path to the directory in which it’s saved, followed by the file name. fas &lt;- &quot;grass.fasta&quot; 11.3 Creating an alignment DECIPHER lets us create alignments in a couple of ways, since we downloaded sequence from a protein-coding gene (Glu-1). We can align the sequences directly, or we can have the program translate the DNA sequences into amino acid sequences, then align the amino acid sequences. If the sequences you want to align are not protein-coding, then you can only align the sequences directly. This part has a couple of steps. First, pass the fasta file into an object formatted as a DNAStringSet object using the command readDNAStringSet. dna &lt;- readDNAStringSet(fas) dna ## DNAStringSet object of length 13: ## width seq names ## [1] 1521 ATGGCTAAGCGGCTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG JX915632 ## [2] 1506 ATGGCTAAGCGGTTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG EF105403.1 ## [3] 1506 ATGGCTAAGCGGCTGGTCCTCTT...ATTGTCGGCTAGCCAGTGATAG DQ073553.1 ## [4] 1749 ATGGCTAAGCGGTTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG FJ481575.1 ## [5] 2100 ATGGCTAAGCGGTTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG EF204545.1 ## ... ... ... ## [9] 2052 ATGGCTAAGCGACTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG AY804128.1 ## [10] 1650 ATGGCTAAGCGGTTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG AY303125.2 ## [11] 1665 TCATCACCCACAACACCGAGCAC...CGCATTGTCGGCCAGCCAGTGA KF887414.1 ## [12] 2296 CAAAACTAGAGATCAATTCATTG...AAAACGGAAAGCTTCTCCATCC D82941.1 ## [13] 2046 ATGGCTAAGCAGCTGGTCCTCTT...CTCCCTGTCGGCCAGCCAGTAG JX276655.1 (You might have noticed a warning message about an invalid character type. Sometimes this happens when you download data from GenBank, because people may have made a mistake in the nucleotide sequence when they submitted their samples. Since it is only one base (and the sequences themselves are at least 1500 bp long), so excluding it is unlikely to bias our results.) Although it might look like the sequences are aligned in the DNAStringSet object, they really aren’t. To do so requires another command. First, let’s align our sequences using just the nucleotides. DNA.no_trans &lt;- AlignSeqs(dna) ## Determining distance matrix based on shared 10-mers: ## ================================================================================ ## ## Time difference of 0.01 secs ## ## Clustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0.01 secs ## ## Aligning Sequences: ## ================================================================================ ## ## Time difference of 0.56 secs ## ## Iteration 1 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.8 secs ## ## Iteration 2 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 1.12 secs ## ## Refining the alignment: ## ================================================================================ ## ## Time difference of 0.9 secs We can also align our sequences after they are first translated. The translated amino acids are aligned, and then the sequences is reverse-translated back to nucleotides. DNA.trans &lt;- AlignTranslation(dna) ## Determining distance matrix based on shared 5-mers: ## ================================================================================ ## ## Time difference of 0.01 secs ## ## Clustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0.01 secs ## ## Aligning Sequences: ## ================================================================================ ## ## Time difference of 0.3 secs ## ## Iteration 1 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.3 secs ## ## Iteration 2 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.3 secs Translating the nucleotide sequences sped up the alignment process, although both were fast enough it isn’t a big deal to directly align the nucleotides. Your choice of which alignment procedure to use will largely come down to whether you are using coding sequence and how divergent your samples are. If you aren’t using coding sequence, you will need to align using the nucleotides. If you have samples from deeply divergent species (especially if they come from different phyla), you will generally get a better alignment if you let the program translate your nucleotide sequence to amino acids first. Now that we’ve created alignments, it would be helpful to visually check them. (This is possible if your sequences aren’t too long, but can become really hard once you start dealing with very long stretches of DNA!) The BrowseSeqs command opens a browser window with the aligned sequences. Just remember which window belongs to each alignment! BrowseSeqs(DNA.no_trans) BrowseSeqs(DNA.trans) You can scroll through the browser windows to see the full alignment. DECIPHER automatically color-codes the nucleotides, which makes it easier to pick out when a sequence doesn’t match the others. At the very bottom, DECIPHER displays a consensus sequence, which we can also look at to identify which bases have mutations (or gaps). The first thing that jumps out it how the two alignment methods resulted in alignments of different lengths. The alignment from the AlignTranslation method is longer than the alignment from the AlignSeqs method. How the gaps are inserted also differ quite a bit. At this point, the alignment we choose to use is basically a judgment call. You have to decide which alignment seems “better” to you. With the grass sequences, sample AJ314771.1 doesn’t quite seem to fit well with the AlignTranslation alignment. There are long stretches of the sequence that aren’t aligned with anything else. This doesn’t seem to be the case for the AlignSeqs alignment. If we chose to go ahead with the AlignTranslation alignment, it would make sense to remove sample AJ314771.1 from our fasta file. You may come across a situation where one (or more) sequences don’t seem to fit very well with the others. The best option going forward is to remove those sequences, as keeping them will cause issues when it comes time to infer the phylogeny. The alignSeqs command allows us to change the gap opening and gap extension penalties. The default setting (which we used above, since we did not specify anything in the alignSeqs or alignTranslation commands) is to assign a minimum and maximum cost for each. For gap opening, the cost is -18 for nearly identical sequences and -14 for sequences that are more distantly related. For gap extension, those costs are -3 and -2. Let’s see what happens when we change the costs. DNA.no_trans.1 &lt;- AlignSeqs(dna, gapOpening = c(-20, -10), gapExtension = c(-5, -1)) ## Determining distance matrix based on shared 10-mers: ## ================================================================================ ## ## Time difference of 0.01 secs ## ## Clustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Aligning Sequences: ## ================================================================================ ## ## Time difference of 0.56 secs ## ## Iteration 1 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.75 secs ## ## Iteration 2 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 1.23 secs ## ## Refining the alignment: ## ================================================================================ ## ## Time difference of 1.02 secs BrowseSeqs(DNA.no_trans.1) Changing the gap opening and gap extension costs may or may not make a difference. In many cases, the default parameters will work just fine. However, it is always wise to check additional values! For the grass samples, it would be reasonable to use the alignment generated by the AlignSeqs method. This is a judgment call more than anything else - there are large sections of the alignment that include all the sequences with minimal changes. We’ll want to trim it to remove the ends with very little sequence coverage. We will keep everything between base 140 and 3373. To trim the sequences, we will write a new fasta file, then use it to create a new DNAbin object. If you haven’t already loaded the ape library in your R session, you should do so now using the library(ape) command. writeXStringSet(DNA.no_trans, file=&quot;grass_aligned.fasta&quot;) grass.align &lt;- read.dna(&quot;grass_aligned.fasta&quot;, format=&quot;fasta&quot;, as.matrix=TRUE) The trick for this step is that we specified the grass.align object be loaded as a matrix, not as a list. We can subset our sequences using brackets since grass.align is in matrix format. grass.trimmed &lt;- grass.align[,140:3373] grass.trimmed ## 13 DNA sequences in binary format stored in a matrix. ## ## All sequences of same length: 3234 ## ## Labels: ## JX915632 ## EF105403.1 ## DQ073553.1 ## FJ481575.1 ## EF204545.1 ## AJ314771.1 ## ... ## ## Base composition: ## a c g t ## 0.310 0.303 0.273 0.115 ## (Total: 42.04 kb) Congratulations! You now have a trimmed alignment, ready for inferring trees. To be on the safe side, we will save it as a fasta file. write.dna( grass.align, file = &#39;grass_aligned.fasta&#39;, format = &#39;fasta&#39; ) R BASICS R has both data types and data structures. Data types (like character (for letters) or numeric (for real or decimal numbers)) can be combined to form data structures. Some of the data structures include: vector list matrix data frame The data structures differ based on their size and what data types they can accept. A vector is a single dimension collection of one data type. You can have vectors made up of many character data types or many numerical data types, but you can’t have a vector of both character and numerical data types together. For example, a vector of numeric data might look like this: 1 1 2 3 5 DNAbin objects are normally formatted as lists, which can be thought of as a multidimensional collection of vectors where each vector can be of a different type. (Within a vector everything is still a single character type.) In the code above, we specified the DNAbin object be formatted as a matrix. The matrix data structure is basically vectors in more than one dimensional, which means all the elements within a matrix must be the same data type (in this case, everything was a character). A matrix of numeric data like the vector example above might look like this: [,1] [,2] [,3] [,4] [,5] [1,] 1 1 2 3 5 [2,] 2 3 5 7 11 In a matrix (as well as in a data frame, which we haven’t discussed), the position of an entry can be specificed using brackets. The first coordinate in the bracket indicates the row, while the second coordinate indicates the column. For the matrix above, [2,5] points to the number 11, which is the entry in the second row and fifth column. If we want to point to an entire row, we can leave off the second coordinate. [1,] points to the entire first row. If we want to point to an entire column, we have two choices. We could use either [,1] or just [1]. R will interpret both of those commands as pointing to column 1. By making the DNAbin object a matrix, we could subset it like a matrix. That’s what we did with the brackets. grass.align[,140:3373] The comma at the beginning of the bracket told R that we wanted to keep all the rows in the matrix grass.align. The 140:3373 told R to keep all the columns between column 140 and column 3372 (as well as those two columns). If we had chosen to remove one of our samples (let’s say, the third sample), we could use the brackets to do so as well. The command for that would look like: kept.sequences &lt;- grass.align[c(1:2,4:13),] The c(1:2,4:13) is telling R that we want to keep all the sequences between the 1st and 2nd rows, as well as all the sequences between the 4th and 13th row. We have to use the c() syntax because we have two sets of rows to keep. sessionInfo() ## R version 4.0.2 (2020-06-22) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.3 LTS ## ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 parallel stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] DECIPHER_2.18.1 RSQLite_2.2.1 Biostrings_2.58.0 ## [4] XVector_0.30.0 IRanges_2.24.1 S4Vectors_0.28.1 ## [7] BiocGenerics_0.36.1 BiocManager_1.30.10 ape_5.4-1 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.8 pillar_1.4.6 compiler_4.0.2 jquerylib_0.1.4 ## [5] tools_4.0.2 zlibbioc_1.36.0 bit_4.0.4 digest_0.6.25 ## [9] memoise_1.1.0 evaluate_0.14 lifecycle_1.0.0 tibble_3.0.3 ## [13] nlme_3.1-149 lattice_0.20-41 pkgconfig_2.0.3 rlang_0.4.10 ## [17] DBI_1.1.0 yaml_2.2.1 xfun_0.26 stringr_1.4.0 ## [21] knitr_1.33 fs_1.5.0 vctrs_0.3.4 hms_0.5.3 ## [25] bit64_4.0.5 grid_4.0.2 R6_2.4.1 ottrpal_0.1.2 ## [29] rmarkdown_2.10 bookdown_0.24 blob_1.2.1 readr_1.4.0 ## [33] magrittr_2.0.2 ellipsis_0.3.1 htmltools_0.5.0 stringi_1.5.3 ## [37] crayon_1.3.4 "],["the-neighbor-joining-method-of-tree-estimation.html", "Chapter 12 The neighbor joining method of tree estimation 12.1 Models of molecular evolution", " Chapter 12 The neighbor joining method of tree estimation There are two basic types of tree estimation methods: distance methods (which includes neighbor joining, discussed here) and tree-searching methods (which we will cover in later sections). The first phylogenetic trees were built using distance methods. Strictly speaking, these methods can be considered phenetic methods, not phylogenetic methods, since these methods group taxa based on similarity instead of attempting to find the most likely tree. For all practical purposes, though, we can include neighbor joining in under the umbrella of phylogenetics. In distance-based methods like neighbor joining, the genetic data is converted into a distance matrix, which is used to group taxa based on the genetic distance between them. Neighbor joining specifically works via star decomposition. Let’s take a look at an example (adapted from (Fred Opperdoes)[http://www.deduveinstitute.be/~opperd/private/neighbor.html]). We have 5 taxa (A,B,C,D, and E) for which we would like to infer a phylogeny. We’ve calculated the following distances among all the taxa: The shortest distance between any taxa is 13, which means that A and B are most closely related to each other and will form our first group. We begin with all the taxa forming a star shape, and then we add a branch that connects A and B. We keep grouping taxa until the entire star has been resolved into bifurcating branches (nodes that connect two, and only two, branches). For our example tree, we eventually end up with this tree: The neighbor joining method is very fast, requires very few computational resources, and is statistically consistent. It will also always result in only a single tree topology. Unfortunately, many people will become overly confident that the single neighbor joining tree is the true tree, which is not necessarily true. Nowadays, most researchers might start their analysis with a neighbor joining tree, but they generally go on to infer trees using one of the other methods. There is another type of distance method you might hear about called UPGMA (unweighted pair group method with arithmetic mean). This is a hierarchical clustering method. However, the tree built using UPGMA depends greatly on the order in which the taxa are added, unlike the neighbor joining method (which will result in the same tree no matter what order the samples are added). As a result, the UPGMA method is almost never used in phylogenetics today. 12.1 Models of molecular evolution In the example above, we kind of glossed over the process of converting DNA sequence into genetic distances. In its simplest form, every mutation is given a value, and the total value of all mutations is then used to calculate a genetic distance. But wait, you might be thinking. How do researchers decide what value to assign each mutation? Are all mutations given the same value, or do some changes “cost” more than others? Aren’t some mutations considered more unlikely than others? These are all excellent questions that should be considered whenever dealing with phylogenetic analysis. Luckily, we don’t have to answer all these questions ourselves. Instead, we can look at published models of molecular evolution (also called substitution models) and decide which model fits our data the best. 12.1.1 JC69 A model of molecular evolution is a set of rules that determines how much each mutation costs relative to all other mutations. One of the earliest published models is the JC69 model (sometimes written as JC), proposed by Jukes and Cantor in 1969. The JC69 model assumes equal base frequencies (that is, each nucleotide makes up 25% of the bases in the DNA sequence), as well as equal mutation rates. A mutation of an A to a T is the same as the mutation as a T to an A or an A to a C. As a result, the JC69 model has only 1 parameter - the mutation rate. 12.1.2 K2P Many other models of molecular evolution have been published since JC69. One of the more popular ones is the Kimura two-parameter model (also called K80, or K2P). This model still assumes equal base frequencies, but allows for a distinct mutation rate for transitions (mutations between purines or pyrimidines) and a different mutation rate for tranversions (mutations from purine to pyrimidine, or vice versa). As you might have guessed from the name, this particular model has two parameters. 12.1.3 GTR One of the most complex models you might come across is the general time reversible model, or GTR. This model is extremely flexible but also parameter-heavy. There are no assumptions about base frequencies, and each possible mutation is given its own mutation rate. (A quick note: the mutation rate from A to G is the same as the mutation rate from G to A in this model.) As a result, this model has 9 parameters: 6 mutation rates + 3 base frequencies. (Because the sum of the 4 base frequencies must equal 1, we only have to describe 3 of them in order to calculate all 4. That’s why we only need 3 parameters to model the base frequencies for GTR.) 12.1.4 Other parameters Sometimes you will run across a model that has “+ I” added to it (like GTR + I). The “I” refers to a invariant sites parameter. In these models, each base has a certain probability of being invariate, or unlikely to mutate. Another option you might see is using a gamma distribution to estimate how many times any given base in a sequence might mutate. We often think of mutation as a one-and-done process, where a nucleotide might mutate only once. This isn’t a bad assumption; in fact, given that mutation is so rare, it is extremely unlikely for a nucleotide to mutate multiple times, though it does happen (particularly as divergence times between taxa increase). A solution to this dilemma is to include a parameter that describes how many times a particular nucleotide has undergone mutation. A gamma distribution is used because the highest probability is found in the smallest values of x, with a low probability of larger values of x (which would be multiple mutation hits at the same nucleotide). A model using a gamma distribution with have a “+ G”. Finally, some models with have a “+ SS” added to it. The SS indicates a site-specific variation parameter. These models will estimate different mutation rates for each codon position. Site-specific models are much less common than models that include invariate sites parameters or a $ parameter. 12.1.5 How do I choose a model? There are enough substitution models out there that it can be a bit overwhelming to pick one for your phylogenetic analyses. (The models discussed above are in no way an exhaustive list.) Many researchers will have a favorite model they use, while others will rely model test programs to tell them which model of molecular evolution best fits their data. Although GTR + I + $ might be the most biologically realistic model, it is also parameter-heavy and may not be the best choice when dealing with a sequence alignment that includes only a small number of phylogenetically-informative sites. ## Determining distance matrix based on shared 10-mers: ## ================================================================================ ## ## Time difference of 0.01 secs ## ## Clustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0.01 secs ## ## Aligning Sequences: ## ================================================================================ ## ## Time difference of 0.56 secs ## ## Iteration 1 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.78 secs ## ## Iteration 2 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 1.12 secs ## ## Refining the alignment: ## ================================================================================ ## ## Time difference of 0.88 secs "],["building-a-neighbor-joining-tree.html", "Chapter 13 Building a neighbor joining tree 13.1 The phyDat object 13.2 Choosing a substitution model 13.3 Building the neighbor joining tree 13.4 Visualizing the neighbor joining tree 13.5 Saving your trees", " Chapter 13 Building a neighbor joining tree We are finally ready to start building trees from our data. For these analyses, we will use an R package called phangorn. If you’d like to learn more about it, you can find the manual here. phangorn (Phylogenetic Reconstruction and Analysis) is stored in the CRAN repository, so we will use install.packages for the installation. install.packages(&#39;phangorn&#39;) library(phangorn) 13.1 The phyDat object phangorn uses a data structure called phyDat to store information. You can either load the fasta file of your alignment into a phyDat object, or you can directly convert the DNAbin object of your alignment into a phyDat object. You will also want to make sure you have access to your DNAbin object, since we will need that for the model testing. #Loading a fasta file grass.phy &lt;- read.phyDat(&#39;grass_aligned.fasta&#39;, format = &#39;fasta&#39;, type = &#39;DNA&#39;) #Converting your DNAbin object grass.align &lt;- read.dna(&#39;grass_aligned.fasta&#39;, format = &#39;fasta&#39;) grass.phy &lt;- phyDat(grass.align) grass.phy ## 13 sequences with 3381 character and 1238 different site patterns. ## The states are a c g t The phyDat object is remarkably similar to the DNAbin object - this isn’t too surprising, since the same team wrote both ape and phangorn. R BASICS If you are pausing your R environment on AnVIL (or have not closed an R session), you may still have all the objects you created previously still available. To check this, you can use the list command. ls() R will print all the objects that are still stored in the workspace. If you see your aligned DNAbin object (which can also bee seen in the Environment tab in the upper right box of RStudio), you can directly convert it to a phyDat object instead of loading the fasta file first. 13.2 Choosing a substitution model phangorn can test our data against 24 different substitution models to determine which is the best fit. We first have to create a “guide” tree. (In future releases of phangorn creating this tree won’t be necessary, but for now it doesn’t take much extra time to create a tree.) dist.matrix &lt;- dist.dna(grass.align) dist.matrix ## JX915632 EF105403.1 DQ073553.1 FJ481575.1 EF204545.1 ## EF105403.1 0.018503109 ## DQ073553.1 0.018486610 0.009175541 ## FJ481575.1 0.053465970 0.059763282 0.062250797 ## EF204545.1 0.071054126 0.076242240 0.077482792 0.058401695 ## AJ314771.1 0.098387036 0.105024012 0.103575748 0.111726613 0.104200261 ## FJ481569.1 0.066921872 0.068194138 0.069428145 0.079685257 0.083719318 ## DQ073533.1 0.110258627 0.110258627 0.110174261 0.129491194 0.123022644 ## AY804128.1 0.070891254 0.078663432 0.077301449 0.098013117 0.095612138 ## AY303125.2 0.134898940 0.140451748 0.140345966 0.156127330 0.155399615 ## KF887414.1 0.108883110 0.115798850 0.114317931 0.125235849 0.132797654 ## D82941.1 0.229308574 0.234242825 0.230816281 0.245639168 0.252112954 ## JX276655.1 0.220197471 0.226712222 0.223309915 0.233015149 0.226285267 ## AJ314771.1 FJ481569.1 DQ073533.1 AY804128.1 AY303125.2 ## EF105403.1 ## DQ073553.1 ## FJ481575.1 ## EF204545.1 ## AJ314771.1 ## FJ481569.1 0.116918944 ## DQ073533.1 0.157034064 0.105988312 ## AY804128.1 0.119801346 0.088583610 0.125139889 ## AY303125.2 0.175826848 0.145832849 0.125235849 0.156008381 ## KF887414.1 0.147859497 0.107203382 0.121715409 0.133466274 0.139333101 ## D82941.1 0.274378224 0.235622139 0.249510345 0.234105767 0.271596554 ## JX276655.1 0.254310536 0.229714807 0.252112954 0.233162450 0.258487550 ## KF887414.1 D82941.1 ## EF105403.1 ## DQ073553.1 ## FJ481575.1 ## EF204545.1 ## AJ314771.1 ## FJ481569.1 ## DQ073533.1 ## AY804128.1 ## AY303125.2 ## KF887414.1 ## D82941.1 0.249182286 ## JX276655.1 0.254834070 0.110258627 str(dist.matrix) ## &#39;dist&#39; num [1:78] 0.0185 0.0185 0.0535 0.0711 0.0984 ... ## - attr(*, &quot;Size&quot;)= int 13 ## - attr(*, &quot;Labels&quot;)= chr [1:13] &quot;JX915632&quot; &quot;EF105403.1&quot; &quot;DQ073553.1&quot; &quot;FJ481575.1&quot; ... ## - attr(*, &quot;Upper&quot;)= logi FALSE ## - attr(*, &quot;Diag&quot;)= logi FALSE ## - attr(*, &quot;call&quot;)= language dist.dna(x = grass.align) ## - attr(*, &quot;method&quot;)= chr &quot;K80&quot; The distance matrix stores all the distances in the lower half of the table to save space. This particular matrix used the K80 model (also known as the K2P model) to calculate the distances. When we use the str(dist.matrix) command, we can see the model used stored in the method attribute. Next, we make a very quick neighbor joining tree to act as the guide tree. We then run the model test command using our phyDat object and the guide tree. tree.guide &lt;- NJ(dist.matrix) mod.test &lt;- modelTest(grass.phy, tree = tree.guide) ## [1] &quot;JC+I&quot; ## [1] &quot;JC+G&quot; ## [1] &quot;JC+G+I&quot; ## [1] &quot;F81+I&quot; ## [1] &quot;F81+G&quot; ## [1] &quot;F81+G+I&quot; ## [1] &quot;K80+I&quot; ## [1] &quot;K80+G&quot; ## [1] &quot;K80+G+I&quot; ## [1] &quot;HKY+I&quot; ## [1] &quot;HKY+G&quot; ## [1] &quot;HKY+G+I&quot; ## [1] &quot;SYM+I&quot; ## [1] &quot;SYM+G&quot; ## [1] &quot;SYM+G+I&quot; ## [1] &quot;GTR+I&quot; ## [1] &quot;GTR+G&quot; ## [1] &quot;GTR+G+I&quot; As the model test runs, R prints out most of the models being tested. For some reason, R doesn’t print the basic models. The first three models listed are JC + I, JC + G, and JC + G + I. While these models are being tested, the program is also testing the basic JC model. mod.test ## Model df logLik AIC AICw AICc AICcw BIC ## 1 JC 23 -12889.65 25825.30 2.700386e-211 25825.63 3.157131e-211 25966.20 ## 2 JC+I 24 -12848.73 25745.47 5.846250e-194 25745.82 6.737694e-194 25892.49 ## 3 JC+G 24 -12841.04 25730.08 1.284266e-190 25730.43 1.480093e-190 25877.10 ## 4 JC+G+I 25 -12841.04 25732.08 4.724094e-191 25732.46 5.363607e-191 25885.23 ## 5 F81 26 -12712.05 25476.11 1.807454e-135 25476.53 2.020447e-135 25635.38 ## 6 F81+I 27 -12670.12 25394.24 1.083122e-117 25394.69 1.191340e-117 25559.64 ## 7 F81+G 27 -12661.52 25377.04 5.877060e-114 25377.49 6.464260e-114 25542.44 ## 8 F81+G+I 28 -12661.52 25379.04 2.161804e-114 25379.53 2.338246e-114 25550.57 ## 9 K80 24 -12675.91 25399.82 6.659747e-119 25400.18 7.675234e-119 25546.84 ## 10 K80+I 25 -12625.77 25301.54 1.460748e-97 25301.93 1.658493e-97 25454.69 ## 11 K80+G 25 -12615.42 25280.84 4.559902e-93 25281.23 5.177187e-93 25433.99 ## 12 K80+G+I 26 -12615.42 25282.84 1.677274e-93 25283.26 1.874926e-93 25442.12 ## 13 HKY 27 -12490.04 25034.08 1.748144e-39 25034.53 1.922808e-39 25199.48 ## 14 HKY+I 28 -12441.45 24938.91 8.118092e-19 24939.39 8.780675e-19 25110.43 ## 15 HKY+G 28 -12430.70 24917.40 3.787695e-14 24917.89 4.096840e-14 25088.93 ## 16 HKY+G+I 29 -12430.70 24919.40 1.393244e-14 24919.92 1.480992e-14 25097.06 ## 17 SYM 28 -12666.82 25389.65 1.076040e-116 25390.13 1.163864e-116 25561.17 ## 18 SYM+I 29 -12619.36 25296.72 1.621861e-96 25297.24 1.724008e-96 25474.38 ## 19 SYM+G 29 -12609.63 25277.27 2.724038e-92 25277.79 2.895602e-92 25454.92 ## 20 SYM+G+I 30 -12609.63 25279.27 1.001914e-92 25279.82 1.046030e-92 25463.04 ## 21 GTR 31 -12462.58 24987.15 2.709162e-29 24987.74 2.776339e-29 25177.06 ## 22 GTR+I 32 -12406.95 24877.89 1.439643e-05 24878.52 1.447278e-05 25073.92 ## 23 GTR+G 32 -12396.11 24856.22 7.310833e-01 24856.85 7.349605e-01 25052.25 ## 24 GTR+G+I 33 -12396.11 24858.22 2.689024e-01 24858.89 2.650250e-01 25060.38 phangorn calculates multiple statistics that can be used to judge the fit of all the models. Which one you choose depends on what you prefer, although the field standard is generally to use the Akaike Information Criterion. This is a single number that combines how well the model fits the data (as determined by the log likelihood score) with a penalty for increasing model complexity. More complex models will almost always fit the data better, but in small datasets it can be difficult to get good estimates of every parameter when the model is complex. With AIC, we might find the GTR + G + I model fits the best, but we only have enough samples to estimates 2 parameters with any confidence. In this case, the AIC score might tell us to use the K80 (K2P) model. Smaller numbers are better when it comes to AIC. This is also the case for AICc (which is a “second generation” or updated calculate of AIC) and BIC (the Bayesian Information Criterion, a version of AIC that includes a stronger penalty for additional parameters). In RStudio, you canclick on “mod.test” in the Environment tab from the pane in the upper right corner. That will open the results of our model test analysis in a separate window. If we click on “AIC” or “AICc”, we can order the models by the AIC values. When we do this, we see the lowest AIC and AICc values are for the GTR + G model, which is what we will use going forward. 13.3 Building the neighbor joining tree We’ve already calculated a distance matrix above, but this time we will specify the model we want to use. dist.matrix &lt;- dist.dna(grass.align, model = &quot;GTR + G&quot;) tree &lt;- NJ(dist.matrix) tree But wait, why are we getting an error message? As it turns out, the modelTest command might test 24 different models, but the dist.dna command can’t use all of those models. This is frustrating but also not uncommon when doing phylogenetic analyses. Unfortunately, not every program supports every substitution model. dist.dna appears to support the following models: RAW, JC69, K80, F81, K81, F84, T92, TN93, GG95, LOGDET, BH87, PARALIN, N, TS, TV, INDEL, INDELBLOCK. We can check which of these models has the lowest AIC from our earlier model test. Surprisingly, it’s the K80 model, which is what we used initially. dist.matrix &lt;- dist.dna(grass.align, model = &quot;K80&quot;) tree &lt;- NJ(dist.matrix) 13.4 Visualizing the neighbor joining tree Let’s take a look at the neighbor joining tree. plot(tree, type = &quot;unrooted&quot;) While we have indeed generated a tree, it’s not really the easiest to interpret at the moment. It’s hard to see what the relationships among taxa are because the tips are labeled with GenBank accession numbers instead of taxa names. Also, we really ought to declare an outgroup. First let’s change the tip labels. This is simply a matter of replacing each accession number with the taxon name. We do this by creating a vector of taxon names (matching the order of the accession numbers), then replacing the tip.label variable in our tree object. Because most of us are not plant experts, we’ll use the common names for each sample, but it’s also acceptable to use the scientific names. tree$tip.label ## [1] &quot;JX915632&quot; &quot;EF105403.1&quot; &quot;DQ073553.1&quot; &quot;FJ481575.1&quot; &quot;EF204545.1&quot; ## [6] &quot;AJ314771.1&quot; &quot;FJ481569.1&quot; &quot;DQ073533.1&quot; &quot;AY804128.1&quot; &quot;AY303125.2&quot; ## [11] &quot;KF887414.1&quot; &quot;D82941.1&quot; &quot;JX276655.1&quot; new.labels &lt;- c(&#39;wheat&#39;, &#39;intermediate wheatgrass&#39;, &#39;mammoth wild rye&#39;, &#39;wheatgrass&#39;, &#39;tall wheatgrass&#39;, &#39;rye&#39;, &#39;Asiatic grass&#39;, &#39;crested wheatgrass&#39;, &#39;Tauschs goatgrass&#39;, &#39;medusahead rye&#39;, &#39;mosquito grass&#39;, &#39;barley_D-hordein&#39;, &#39;Siberian wild rye_D-hordein&#39; ) tree$tip.label &lt;- new.labels Next, we declare our outgroup (in this case, the two D-hordein samples) and root our tree. (Remember, we did this in our first exercise using R.) tree.root &lt;- root(tree, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) plot(tree.root, type = &quot;phylogram&quot;, main = &#39;Neighbor Joining, Glu-1&#39;) Now we have a tree that we can begin to make sense of. To an non-botanist, it seems interesting the samples with the common name “wheatgrass” don’t appear to be clustering together. Common names can be misleading about phylogenetic relationships! 13.5 Saving your trees You want to be sure to save the rooted tree and model test results to the persistent disk. write.tree(tree.root, file = &#39;nj_grass.tre&#39;) write.table(mod.test, file = &#39;grass_model_test&#39;, quote=F, sep=&#39;\\t&#39;) sessionInfo() ## R version 4.0.2 (2020-06-22) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.3 LTS ## ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 parallel stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] phangorn_2.5.5 DECIPHER_2.18.1 RSQLite_2.2.1 ## [4] Biostrings_2.58.0 XVector_0.30.0 IRanges_2.24.1 ## [7] S4Vectors_0.28.1 BiocGenerics_0.36.1 ape_5.4-1 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.8 highr_0.8 pillar_1.4.6 compiler_4.0.2 ## [5] jquerylib_0.1.4 tools_4.0.2 zlibbioc_1.36.0 bit_4.0.4 ## [9] digest_0.6.25 memoise_1.1.0 evaluate_0.14 lifecycle_1.0.0 ## [13] tibble_3.0.3 nlme_3.1-149 lattice_0.20-41 pkgconfig_2.0.3 ## [17] rlang_0.4.10 igraph_1.2.6 fastmatch_1.1-0 Matrix_1.2-18 ## [21] DBI_1.1.0 yaml_2.2.1 xfun_0.26 stringr_1.4.0 ## [25] knitr_1.33 fs_1.5.0 vctrs_0.3.4 hms_0.5.3 ## [29] bit64_4.0.5 grid_4.0.2 R6_2.4.1 ottrpal_0.1.2 ## [33] rmarkdown_2.10 bookdown_0.24 blob_1.2.1 readr_1.4.0 ## [37] magrittr_2.0.2 ellipsis_0.3.1 htmltools_0.5.0 quadprog_1.5-8 ## [41] stringi_1.5.3 crayon_1.3.4 "],["about-the-authors.html", "About the Authors", " About the Authors These credits are based on our course contributors table guidelines.     Credits Names Pedagogy Lead Content Instructor Elizabeth Humphries Content Idea Contributor Ava Hoffman, Frederick Tan Content Directors Elizabeth Humphries, Jeff Leek, Frederick Tan Production Content Publisher Ira Gooding Technical Template Publishing Engineers Candace Savonen, Carrie Wright, Ava Hoffman Publishing Maintenance Engineer Candace Savonen Technical Publishing Stylists Carrie Wright, Candace Savonen Package Developers (ottrpal) John Muschelli, Candace Savonen, Carrie Wright Funding Funder National Human Genome Research Institute (NHGRI) Funding Staff Fallon Bachman, Jennifer Vessio, Emily Voeglein   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.3 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2022-06-20 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.3) ## bookdown 0.24 2022-02-15 [1] Github (rstudio/bookdown@88bc4ea) ## callr 3.4.4 2020-09-07 [1] RSPM (R 4.0.2) ## cli 2.0.2 2020-02-28 [1] RSPM (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.14 2019-05-28 [1] RSPM (R 4.0.3) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.6.1 2022-01-22 [1] CRAN (R 4.0.2) ## htmltools 0.5.0 2020-06-16 [1] RSPM (R 4.0.1) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## knitr 1.33 2022-02-15 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.0 2021-02-15 [1] CRAN (R 4.0.2) ## magrittr 2.0.2 2022-01-26 [1] CRAN (R 4.0.2) ## memoise 1.1.0 2017-04-21 [1] RSPM (R 4.0.0) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.3.4 2020-08-11 [1] RSPM (R 4.0.2) ## purrr 0.3.4 2020-04-17 [1] RSPM (R 4.0.3) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 0.4.10 2022-02-15 [1] Github (r-lib/rlang@f0c9be5) ## rmarkdown 2.10 2022-02-15 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.2 2020-11-15 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2022-02-15 [1] Github (R-lib/testthat@e99155a) ## usethis 2.1.5.9000 2022-02-15 [1] Github (r-lib/usethis@57b109a) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2022-02-15 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library 2022 GitHub, Inc. Terms Privacy Security Status Doc "],["references.html", "Chapter 14 References", " Chapter 14 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
