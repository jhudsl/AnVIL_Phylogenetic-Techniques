[["index.html", "Molecular Phylogenetic Techniques About this Book Skills Level AnVIL Collection", " Molecular Phylogenetic Techniques May 06, 2025 About this Book This book is part of a series of books for the Genomic Data Science Analysis, Visualization, and Informatics Lab-space (AnVIL) of the National Human Genome Research Institute (NHGRI). Learn more about AnVIL by visiting https://anvilproject.org or reading the article in Cell Genomics. Skills Level Genetics Programming skills AnVIL Collection Please check out our full collection of AnVIL and related resources: https://hutchdatascience.org/AnVIL_Collection/ "],["introduction.html", "Chapter 1 Introduction 1.1 Motivation 1.2 Target Audience 1.3 Curriculum", " Chapter 1 Introduction This book offers an introduction to molecular phylogenetic analyses using RStudio on AnVIL. Students will learn how to choose sequences for analysis, alignment, and the major methods of tree inference, as well as how to create useful phylogenetic tree figures. 1.1 Motivation Coming soon! 1.2 Target Audience The course is intended for advanced undergraduates with an understanding of evolutionary biology, or for graduate students. Experience with R is not necessary but is helpful. 1.3 Curriculum Coming soon! "],["sign-in.html", "Chapter 2 Sign in", " Chapter 2 Sign in You need to sign into Terra with your Google account to allow your instructor to add you to projects and/or Workspaces associated with your specific class. This is the only way you can launch applications and perform computations on AnVIL. You can access Terra by going to anvil.terra.bio, or by clicking the link on the AnVIL home page. Sign in using the drop-down menu in the upper-left-hand corner. "],["create-a-workspace.html", "Chapter 3 Create a workspace", " Chapter 3 Create a workspace On AnVIL, you use Workspaces to configure and run analyses and share results. Workspaces support interactive analysis with RStudio, Jupyter notebooks, Bioconductor and Galaxy. Workspaces can also save the output generated by running an analysis with a Workspace’s associated “cloud environment.” Check out https://anvilproject.org to learn more about everything you can do within a Workspace. In the drop-down menu on the left, navigate to “Workspaces”. Click the triple bar in the top left corner to access the menu. Click “Workspaces”. Click on the plus icon near the top of left of the page. Name your Workspace and select the Billing Project as indicated by your instructor. Do not change the Bucket Location or Authorization Domain. You can add a Description if you wish. Click “CREATE WORKSPACE”. The new Workspace should now show up under your Workspaces. "],["rstudio.html", "Chapter 4 Working in RStudio 4.1 Launch RStudio Cloud Environment 4.2 Tour RStudio 4.3 Pause RStudio 4.4 Delete RStudio Cloud Environment 4.5 Video Guide", " Chapter 4 Working in RStudio Once you have created a Workspace, you can create an RStudio cloud environment. This will allow you to interface with data and perform genomics-based analyses with add on packages from the Bioconductor community. 4.1 Launch RStudio Cloud Environment Click on the name of the Workspace you just created. You should be routed to a link that looks like: https://anvil.terra.bio/#workspaces/&lt;billing-project&gt;/&lt;workspace-name&gt;. On the top right, Click the gear icon to access your Cloud Environment options. You will see a list of costs because it costs a small amount of money to use cloud computing. Click “CUSTOMIZE”. Click on the first drop down menu to see what other software configurations are available. Scroll down and select RStudio from the Community-Maintained RStudio Environments section. NOTE: AnVIL is very versatile and can scale up to use very powerful cloud computers. It’s very important that you select the cloud computing environment described here to avoid runaway costs. Leave everything else as-is. To create your RStudio Cloud Environment, click on the “CREATE” button. Your Cloud Environment will be available in a few minutes after the cloud resources are provisioned and your software starts up. The upper right corner displays the status and should say “Creating” while resources are being provisioned. After a few minutes, you will see the status change to “Running”. Click on the “R” icon to launch RStudio. You should now see the RStudio interface with information about the version printed to the console. 4.2 Tour RStudio Next, we will be using RStudio and the package Glimma to create interactive plots. See this vignette for more information. The Bioconductor team has created a very useful package to programmatically interact with Terra and Google Cloud. Install the AnVIL package. It will make some steps easier as we go along. BiocManager::install(&quot;AnVIL&quot;) You can now quickly install precompiled binaries using the AnVIL package’s install() function. We will use it to install the Glimma package and the airway package. The airway package contains a SummarizedExperiment data class. This data describes an RNA-Seq experiment on four human airway smooth muscle cell lines treated with dexamethasone. {Note: for some of the packages in this class, you will have to install packaged from the CRAN repository, using the install.packages() function. The examples will show you which install method to use.} ``` r AnVIL::install(c(&quot;Glimma&quot;, &quot;airway&quot;)) ``` &lt;img src=&quot;resources/images/02-rstudio_files/figure-html//1BLTCaogA04bbeSD1tR1Wt-mVceQA6FHXa8FmFzIARrg_g11f12bc99af_0_56.png&quot; alt=&quot;Screenshot of the RStudio environment interface. Code has been typed in the console and is highlighted.&quot; width=&quot;480&quot; /&gt; Load the example data. library(airway) data(airway) The multidimensional scaling (MDS) plot is frequently used to explore differences in samples. When this data is MDS transformed, the first two dimensions explain the greatest variance between samples, and the amount of variance decreases monotonically with increasing dimension. The following code will launch a new window where you can interact with the MDS plot. Glimma::glimmaMDS(assay(airway), group = colData(airway)$dex) Change the colour_by setting to “groups” so you can easily distinguish between groups. In this data, the “group” is the treatment. You can download the interactive html file by clicking on “Save As”. You can also download plots and other files created directly in RStudio. To download the following plot, click on “Export” and save in your preferred format to the default directory. This saves the file in your cloud environment. limma::plotMDS(airway) You should see the plot in the “Files” pane. Select this file and click “More” &gt; “Export” Select “Download” to save the file to your local machine. 4.3 Pause RStudio The upper right corner reminds you that you are accruing cloud computing costs. You should minimize charges when you are not performing an analysis. You can do this by clicking on “Stop cloud environment”. This will release the CPU and memory resources for other people to use. Note that your work will be saved in the environment and continue to accrue a very small cost. Your instructor can delete these environments to stop costs accruing, so it’s a good idea to save code or output somewhere else, such as GitHub or your local machine. 4.4 Delete RStudio Cloud Environment Stopping your cloud environment only pauses your work. When you are ready to delete the cloud environment, click on the gear icon in the upper right corner to “Update cloud environment”. Click on “Delete Environment Options”. If you are certain that you do not need the data and configuration on your disk, you should select “Delete everything, including persistent disk”. Select “DELETE”. 4.5 Video Guide In addition to the steps above, you can review this video guide on how to launch RStudio on AnVIL. The slides for this tutorial are are located here. sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] sass_0.4.8 utf8_1.2.4 generics_0.1.3 xml2_1.3.6 ## [5] stringi_1.8.3 hms_1.1.3 digest_0.6.34 magrittr_2.0.3 ## [9] evaluate_0.23 timechange_0.3.0 bookdown_0.41 fastmap_1.1.1 ## [13] rprojroot_2.0.4 jsonlite_1.8.8 processx_3.8.3 chromote_0.3.1 ## [17] ps_1.7.6 promises_1.2.1 httr_1.4.7 fansi_1.0.6 ## [21] ottrpal_1.3.0 jquerylib_0.1.4 cli_3.6.2 rlang_1.1.4 ## [25] cachem_1.0.8 yaml_2.3.8 tools_4.3.2 tzdb_0.4.0 ## [29] dplyr_1.1.4 curl_5.2.0 png_0.1-8 vctrs_0.6.5 ## [33] R6_2.5.1 lifecycle_1.0.4 lubridate_1.9.3 snakecase_0.11.1 ## [37] stringr_1.5.1 janitor_2.2.0 pkgconfig_2.0.3 pillar_1.9.0 ## [41] bslib_0.6.1 later_1.3.2 glue_1.7.0 Rcpp_1.0.12 ## [45] highr_0.11 xfun_0.48 tibble_3.2.1 tidyselect_1.2.0 ## [49] knitr_1.48 htmltools_0.5.7 websocket_1.4.2 rmarkdown_2.25 ## [53] webshot2_0.1.1 readr_2.1.5 compiler_4.3.2 askpass_1.2.0 ## [57] openssl_2.1.1 "],["phylogenetics-basics.html", "Chapter 5 Phylogenetics basics 5.1 How to read a phylogenetic tree 5.2 Outgroups 5.3 Branch lengths", " Chapter 5 Phylogenetics basics 5.1 How to read a phylogenetic tree A phylogeny, or phylogenetic tree, is a diagram that shows the evolutionary history and relationships among or within groups of organisms. Phylogenetics was traditionally a somewhat obscure field in which systematists (biologists concerned with arranging organisms into a tree that showed their ancestral relatedness) arranged related living organisms at the tips (or “leaves” of the tree), and made branches to connect different organisms back to putative ancestral organisms. Here’s a phylogeny of the family Ursidae (the bears). In this tree, all the extant species (or currently living species) are at the tips on the far right side of the phylogeny. Inferences about how the bear species are related become apparent as you move away from the tips down the branches. When two branches meet at a node (as they do at point A), you can assume the species at the tips of those branches share a common ancestor. For example, this phylogeny of the Ursidae indicates that American black bears and Asian black bears share a common ancestor (indicated by the node at point A). However, we don’t know what the common ancestor is for certain, we are just inferring based on similarities between the species that exist today. Nodes that are closer to the tips indicate species that are more closely related (and thus indicate a more recent common ancestor than nodes farther away from the tips). American black bears are more closely related to Asian black bears than to American black bears are to giant pandas, because the American black bear branch connects to a node shared by the Asian black bear branch (point A) before it connects to a node shared with the giant panda branch (point B). Another unusual thing about phylogenies is we can change the order of the taxa on the tips without actually changing the topology of the tree. These two trees are the same, even though we have changed the position of the labels of American black bear and Asian black bear. In phylogenetic trees, relatedness is expressed by the distance to a common node between two species, NOT by whether the labels are near each other. Branches can rotate freely around nodes without changing the tree. 5.2 Outgroups Although this is a phylogeny of the Ursidae, you might have noticed there are two branches belonging to the gray wolf and the spotted seal, neither of which is a bear. These two species are included as outgroups. Outgroups are taxa that are only distantly related to the group of interest and serve as reference points for determining evolutionary changes. 5.3 Branch lengths Branch lengths (the distance between two nodes, or between a node and a tip), may or may not be indicative of the passage of a particular amount of time. It depends on how the tree was inferred (we infer phylogenetic trees, we don’t make them). If the tree is created by parsimony or neighbor-joining methods, the branches simply indicate that there was one (or more) change from the ancestor to the descendant. If the tree was created using maximum likelihood methods, the branch lengths represent how many genetic changes occurred over time. Regardless of how the trees are constructed, they are estimates of what we think happened historically. Each estimate contains within it implicit assumptions about rates of mutation accumulating, likelihood of different types of changes being more common (transitions vs. transversions, for example), and so on. The tree is our best hypothesis as to the history of the organisms on it, but it is only a hypothesis. At one time, only morphological data could be used to make these trees. Thus, phylogenetic trees might have been based on similarities of bone structures, or fur types, or other gross physiological features. Even though the trees were called “phylogenetic” trees, they were not based on genetic data. Now, phylogenetic trees are generally based on DNA sequence (for closely related species) or amino acid sequences (for more distantly related species). Furthermore, the trees are generally based on several genetic loci, rather than on the whole genome. This is changing, with next generation sequencing and advances in computing power. Nevertheless, at present most phylogenetic trees are “gene trees” rather than “species trees,” and it is important to remember that selection or drift on a particular locus can influence a tree so that it reflects the history of the gene, but NOT the history of the species "],["visualizing-trees-in-r.html", "Chapter 6 Visualizing trees in R 6.1 Creating a Newick object 6.2 Drawing trees 6.3 Adding outgroups 6.4 Drawing trees multiple ways 6.5 The phylo class", " Chapter 6 Visualizing trees in R 6.1 Creating a Newick object Computer programs use the Newick tree format for phylogenetic trees. This format uses a series of parentheses, commas, and colons to store information about evolutionary relationships. (A,B) indicates a pair of taxa that form their own group, or clade ((A,B),C) indicates the next most closely related taxon to the A-B clade is taxon C (A:5,B:7) tells the program (and us!) the length of the branch connecting each taxon to the node. In this case, the branch length between the node and A is 5 and the branch length for B is 7. The total distance between A and B is 5+7, or 12. ((A,B),C)); tells the program the tree is complete. If the semicolon is missing at the end, the program will keep looking for information on another taxon. For this exercise, we are going to create an R object in Newick formula that illustrates the relationships among several species of mammals. #install.packages(&#39;ape&#39;) #this installs the ape package #install.packages(&#39;nlme&#39;) #this installs the nlme package library(ape) #this opens the ape package library(nlme) #this opens the nlme package #we first create an object that stores the tree information mammal.1 &lt;- read.tree(text = &quot;((((raccoon:19.19959,bear:6.80041):0.84600, weasel:18.87953):2.09460):3.87382,dog:25.46154);&quot;) #typing the name of the object means R will tell us about it mammal.1 ## ## Phylogenetic tree with 4 tips and 4 internal nodes. ## ## Tip labels: ## raccoon, bear, ## weasel, dog ## ## Rooted; includes branch lengths. We now have a phylogenetic tree loaded into R. Why is it called Newick format? This is what Joe Felsenstein, one of the giants of the phylogenetic field, says: “The Newick Standard was adopted 26 June 1986 by an informal committee meeting convened by me during the Society for the Study of Evolution meetings in Durham, New Hampshire and consisting of James Archie, William H.E. Day, Wayne Maddison, Christopher Meacham, F. James Rohlf, David Swofford, and myself. (The committee was not an activity of the SSE nor endorsed by it). The reason for the name is that the second and final session of the committee met at Newick’s restaurant in Dover, New Hampshire, and we enjoyed the meal of lobsters. The tree representation was a generalization of one developed by Christopher Meacham in 1984 for the tree plotting programs that he wrote for the PHYLIP package while visiting Seattle. His visit was a sabbatical leave from the University of Georgia, which thus indirectly partly funded that work.” 6.2 Drawing trees It is quite difficult for humans to quickly interpret the relationships and branch lengths in the Newick format. Luckily, R (and other phylogenetics programs) can convert Newick formats into a more understandable form. #plot is the command we use to create trees with the ape package #one of the options is the type of tree the command draws #this can also be written as plot(mammal.1, &quot;u&quot;) plot(mammal.1, type=&quot;unrooted&quot;) You’ve inferred an unrooted tree. It probably looks a bit different than trees you’ve seen before (including the one in the previous section); most trees are displayed in a rooted form. We can do that by specifying that we want to draw a phylogram. If you don’t declare an outgroup first, R will choose to root the phylogram halfway between the two longest branches (this is called midpoint rooting). #here we draw a phylogram #alternatively, you can use the command: #plot(plot(mammal.1), as phylogram is the default type plot(mammal.1, type=&quot;phylogram&quot;) Now the tree looks more like the Ursidae tree we examined earlier. The order of the tips is partly determined by the order in which we wrote the taxa in our Newick format. We can change the order of the tips and still have the same tree. mammal.2 &lt;- read.tree(text = &quot;((((bear:6.80041,raccoon:19.19959):0.84600, weasel:18.87953):2.09460):3.87382,dog:25.46154);&quot;) #this bit of code here tells R to put the trees in side-by-side in #a single row (1 row, 2 columns) par(mfrow=c(1,2)) plot(mammal.1) plot(mammal.2) Clades can rotate freely around nodes without changing the relationships among the tips. Although the “weasel” label is closer to “bear” in our first tree than it is in the second tree, the evolutionary distance between the two is the same in both trees, because we trace through the same nodes to find their common ancestor. Both of these trees are exactly the same, in a phylogenetic sense. 6.3 Adding outgroups Let’s add some more taxa to our tree! mammal.3 &lt;- read.tree(text = &quot;((raccoon:19.19959,bear:6.80041):0.84600,((sea_lion:11.99700, seal:12.00300):7.52973,((monkey:100.85930,cat:47.14069):20.59201, weasel:18.87953):2.09460):3.87382,dog:25.46154);&quot;) mammal.3 ## ## Phylogenetic tree with 8 tips and 6 internal nodes. ## ## Tip labels: ## raccoon, bear, sea_lion, ## seal, monkey, cat, ... ## ## Unrooted; includes branch lengths. We’ve now added an additional 5 taxa to our tree of mammalian species. Let’s first take a look at the unrooted tree. plot(mammal.3, type=&quot;u&quot;)#&quot;u&quot; is short for &quot;unrooted&quot; Even with the unrooted tree, we can see that some species are definitely more closely related than others. In fact, it looks like both “cat” and “monkey” are pretty distantly related to the others, since the branches connecting these taxa are much longer than any other branch. Given this information, we will define these two taxa as our outgroup and redraw our tree, this time as a rooted phylogram. #this command tells R that monkey and cat are outgroups mammal.3.root &lt;- root(mammal.3, outgroup = c(&#39;monkey&#39;,&#39;cat&#39;)) plot(mammal.3.root, type=&quot;p&quot;)#&quot;p&quot; is short for &quot;phylogram&quot; 6.4 Drawing trees multiple ways So far you’ve drawn trees in two ways - unrooted, and as a phylogram. For both of these tree types, the branch lengths are scaled to indicate evolutionary distance (or how many changes have occurred). As a result, the tips aren’t all even with each other. There are two other common ways of drawing trees. The radial tree (sometimes called the fan tree) arranges all the branches in a circle. This is a popular way to draw a phylogeny with many tips that would otherwise take up a lot of space. #now we&#39;re looking at three different trees next to each other #basically, figures are in 1 row and 3 columns par(mfrow=c(1,3)) plot(mammal.3, type=&quot;u&quot;) plot(mammal.3.root, type=&quot;p&quot;) plot(mammal.3.root, type=&quot;f&quot;)#f is short for &quot;fan&quot; All three of these trees show exactly the same information. The last common way to draw trees is as a cladogram. Cladograms are a little different than the others, because the branches are not scaled to evolutionary distance. Instead, the tree is drawn so that all the tips (taxa) are lined up. It is often easier to see relationships in a cladogram, particularly if the internode distances (the distance between two internal nodes of a tree) are small. To properly draw a cladogram, we will rewrite our tree in Newick formula so that it doesn’t include branch lengths. mammal.4 &lt;- read.tree(text = &quot;(dog,(raccoon,bear),((seal,sea_lion), ((monkey,cat), weasel)));&quot;) mammal.4.root &lt;- root(mammal.4, outgroup = c(&#39;monkey&#39;,&#39;cat&#39;)) par(mfrow=c(1,2)) plot(mammal.3.root, type=&quot;p&quot;) plot(mammal.4.root, type=&quot;c&quot;)#c is short for &quot;cladogram&quot; QUESTIONS What is the total branch length between “bear” and “raccoon”? (You will need to look at the tree in Newick format.) Does “weasel” share a more common recent ancestor with “seal” or with “sea lion”? Why does it look like “weasel” is more closely related to “bear” in the tree with four taxa, but it looks like “dog” is more closely related to “bear” in the tree with eight taxa? (HINT: Think about the purpose of an outgroup, and whether we specified one for the four-taxa tree.) 6.5 The phylo class When we use the ape package, R converts a tree in Newick format to an object of the phylo class. This is basically a list of four dataframes. str(mammal.3.root) ## List of 4 ## $ edge : int [1:13, 1:2] 9 14 12 10 11 11 10 12 13 13 ... ## $ edge.length: num [1:13] 20.592 2.095 3.874 0.846 19.2 ... ## $ Nnode : int 6 ## $ tip.label : chr [1:8] &quot;raccoon&quot; &quot;bear&quot; &quot;sea_lion&quot; &quot;\\nseal&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Each dataframe holds information about some part of the tree. edge: the number of steps needed to connect two tips. It’s easiest to think of each branch as an edge. edge.length: the length of each corresponding edge, or branch Nnode: the number of nodes in the tree tip.label: the tip names (the taxa) sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] nlme_3.1-164 ape_5.7-1 ## ## loaded via a namespace (and not attached): ## [1] sass_0.4.8 utf8_1.2.4 generics_0.1.3 xml2_1.3.6 ## [5] lattice_0.21-9 stringi_1.8.3 hms_1.1.3 digest_0.6.34 ## [9] magrittr_2.0.3 grid_4.3.2 evaluate_0.23 timechange_0.3.0 ## [13] bookdown_0.41 fastmap_1.1.1 rprojroot_2.0.4 jsonlite_1.8.8 ## [17] processx_3.8.3 chromote_0.3.1 ps_1.7.6 promises_1.2.1 ## [21] httr_1.4.7 fansi_1.0.6 ottrpal_1.3.0 jquerylib_0.1.4 ## [25] cli_3.6.2 rlang_1.1.4 cachem_1.0.8 yaml_2.3.8 ## [29] parallel_4.3.2 tools_4.3.2 tzdb_0.4.0 dplyr_1.1.4 ## [33] vctrs_0.6.5 R6_2.5.1 lifecycle_1.0.4 lubridate_1.9.3 ## [37] snakecase_0.11.1 stringr_1.5.1 janitor_2.2.0 pkgconfig_2.0.3 ## [41] pillar_1.9.0 bslib_0.6.1 later_1.3.2 glue_1.7.0 ## [45] Rcpp_1.0.12 highr_0.11 xfun_0.48 tibble_3.2.1 ## [49] tidyselect_1.2.0 knitr_1.48 htmltools_0.5.7 websocket_1.4.2 ## [53] rmarkdown_2.25 webshot2_0.1.1 readr_2.1.5 compiler_4.3.2 ## [57] askpass_1.2.0 openssl_2.1.1 "],["what-sequences-should-i-choose.html", "Chapter 7 What sequences should I choose?", " Chapter 7 What sequences should I choose? Phylogenies are only as good as the data used to infer them, so it’s worth it to the spend some time carefully choosing the genomic regions and samples you will use. Good planning from the beginning will save you headaches further downstream. First, you should ask yourself: what information are you hoping to gain from the tree? Are you hoping to reconstruct the history of organisms, or the history of a region of DNA, or the history of a protein? The answer will guide your choice of sequence and samples. For closely related species in which you might hope to figure out some sort of information about the divergence between the species (including the timing of the divergence), you would use areas of the genome known to accumulate changes rapidly (non-coding regions that also do not have functionality, or whose functionality is not easily changed by changes in the DNA base sequence). Some examples of rapidly changing genetic regions include the mitochondrial control region, the wobble base on mitochondrial coding regions, and nuclear introns. It is also important to use “dense taxon sampling” among closely related species because any small change can seem disproportionately important in a recent divergence. Having multiple individuals sampled from each phylogenetic unit of interest (could be species, subspecies, or populations) helps to compensate by showing the genetic divergence within a group. This within-group divergence can then be accurately compared to the genetic divergence between two groups. For more divergent species and comparisons, you use areas of the genome that do not change as rapidly. For example, if you wanted to do a survey of the placental mammals, you could choose a gene region that is under enough selection pressure that it mutates more slowly than the regions you would choose for closely related species. If you are examining the relationships among deeply divergent species, or when the base-pair signal is completely swamped out over time, you might search for amino acid sequence similarities instead of DNA sequence similarities. Because of wobble, amino acid sequence can remain the same even when bases change. Sometimes amino acids of similar size/charge/shape can be substituted for others, which would result in a complete change in base pair sequence (and loss of ability to find similar sequences), but allows for finding similarities through amino acid sequence. Even when using protein sequence, it is often helpful to extract the coding sequence (once similar protein sequences have been found), because that adds extra information to fine tune the phylogenetic analysis. This technique can also be used when the primary goal is to trace the history of a particular gene (when the changes in the gene itself are of interest.) To attempt a reconstruction of the evolutionary history of organisms, you really should use multiple lines of evidence and not rely solely on genomic data. For example to reconstruct primate evolution, one looks at the fossil record, molecular divergence, and also phylogeographic evidence (how these things map onto our understanding of the geography of the earth at various crucial time points along primate evolution). Examples of phylogeographic evidence include understanding when terrestrial (land-based) organisms might have been cut off from each other due to the formation of a river or lake, the eradication of a land bridge by melting glaciers and a rise in the earth’s temperature (which raises the sea level). Alas, for this book, we are limited to only using genomic data. "],["finding-sequences-in-genbank.html", "Chapter 8 Finding sequences in GenBank 8.1 Identifying a query sequence on GenBank 8.2 blastn 8.3 Identifying an outgroup", " Chapter 8 Finding sequences in GenBank 8.1 Identifying a query sequence on GenBank For this book, we will use Glu-1 sequences from a variety of species to infer our tree. Glu-1 is a gene that encodes one of the subunits used to make gluten in plants like wheat. We will use this gene to reconstruct some of the deeper phylogenetic relationships among the grasses. We’re going to temporarily leave AnVIL and RStudio and head to NCBI’s website. We start by searching for Glu-1 sequences in the NCBI nucleotide database. At the top of the website, use the pulldown menu to choose “Nucleotide” and enter “glu-1” in the search bar. You might notice that this returns thousands upon thousands of possible sequences. While it’s nice having choices, having too many results makes it difficult to know where to start. Instead, we’re going to narrow down our sequence choices by specifying that we want Glu-1 sequences from common wheat, or Triticum aestivium. This is a good starting point, since we know that common wheat plants make the gluten protein, so the genome should contain Glu-1. The first hit (at least from when this guide was created) is exactly what we’re looking for - the complete coding sequence for the high molecular weight glutenin subunit, the Glu-1 gene. If we click on the link at the top of the entry, we can go to the GenBank page for this particular entry. This page contains a lot of information about the sequence, including which research group generated it, if the sequence was used in published research, and the full taxonomy of the sample. At the top, we also find the accession number, or the unique ID assigned to this particular sequence. Highlight and copy the accession number - this is what we will use for our next step, a BLAST search. 8.2 blastn NCBI created a tool that allows us to use the basic local alignment search tool (BLAST) algorithm to find sequences similar to our query sequence (in this case, the Triticum aestivium sequence we identified above). Here’s a link for NCBI’s web tool: BLAST. There are many tutorials on how to use BLAST (including NCBI’s own), so this section is going to focus primarily on the logic behind choosing sequences for phylogenetic analysis, not just the steps. Once you open the BLAST webpage, you have five options for searching (the tabs at the top of the page). Which method you choose depends on your query sequence. We’re going to work with two of them: blastn, which identifies DNA sequences that are most similar to the DNA (or nucleotide) query sequence; and blastp, which does the same for protein sequences. For the blastn search, all we need to do is paste the accession code from earlier into the search box and change our program selection to somewhat similar sequences (blastn). Next, let’s go down to the bottom of the page to the algorithm parameters section. We need to change the max number of target sequences (the maximum number of sequences for our search to return). Given how rapidly the size of the GenBank databases are growing, leaving this value at 100 means we will miss a lot of sequences that we might otherwise want to see. For now, we can leave the other parameters as the default settings. The click the BLAST button on the bottom left. It can take a couple of minutes for the blastn search to finish. When it does, a webpage similar to the figure above will open. On the right side of the screen, we have the option of applying additional filters to our search. Because we are interested in looking at the deeper phylogenetic relationships among the grass family, we don’t necessarily want any additional Triticum aestivium sequences, so we will filter them out. That leaves us with over 2,000 other sequences from which to choose our taxa. (If you were interested in more shallow phylogenetic relationships, choosing multiple sequences from the same taxa, or dense taxon sampling, is a good decision.) There are three quality-control statistics at which we want to look. query cover: the amount of overlap between our query sequence and the newly-aligned sequence; larger is better _E value_ (expect value): the number of hits expected by chance; like p-values, a lower number is better *per ident (percent identity): the percent similarity between the two sequences; larger is better We can filter or sort on any of these statistics. At this point we need to really look at the aligned sequences and decide which ones we want to use. There are quite a few samples from a variety of grass species that show good overlap, low E values, and high percent identities. Since we have options, we will prioritize choosing samples with complete coding sequence whenever possible (and avoid any sample labeled “pseudogene”, since that isn’t the actual Glu-1 gene sequence). We will focus on these 9 sequences (in addition to the common wheat sequence we identified earlier): EF105403.1, Thinopyrum intermedium (intermediate wheatgrass) DQ073553.1, Leymus racemosus (mammoth wild rye) EF204545.1, Lophopyrum elongatum (tall wheatgrass) AJ314771.1, Secale cereale (rye) FJ481569.1, Henrardia (a genus of Asiatic wheatgrass) DQ073533.1, Agropyron cristatum (crested wheatgrass) AY804128.1, Aegilops tauschii (Tausch’s goatgrass) AY303125.2, Taeniathetum caput (medusahead rye) KF887414.1, Dasypyrum villosum (mosquito grass) A quick check of the taxonomy confirms that all of these samples are from the grass family, family Poaceae. 8.3 Identifying an outgroup We have two approaches we could take for identifying an outgroup - we could use a more distantly related taxon, or we could use a homologous gene sequence from a more closely-related taxon. When we look up information about the Poaceae, we find there are three clades within the family - cereal grasses (like wheat), bamboos, and grasses (such as those species found in natural grasslands or cultivated for lawns and pastures). In the list of 10 related sequences above, we don’t have any sequences from the bamboos (subfamily Bambusoideae). Glu-1 from a bamboo species might make a nice outgroup, if we can find a sequence for it. First, we’ll try another blastn search, this time setting the program selection to more dissimilar sequences (discontiguous megablast) When we get those results back, we can filter for samples within the subfamily Bambusoideae. Alas, we have no sequences that match. The next thing we can try is a blastp search. These searches are nice for identifying more distantly related samples, because the protein sequence of a gene changes more slowly than the nucleotide sequence. In order to run a blastp search, we need a protein sequence for our query. Luckily, we chose a full coding sequence. When we look at the GenBank entry for JX915632, we can find the coding sequence translated into the amino acids at the bottom of the page. We can copy this amino acid sequence and paste it into the query box on the blastp page. After the blastp search finishes and we filter out Triticum aestivium results, we end up with several hundred matches. Great! …or is it? Unfortunately, all of the samples that are returned have very poor query coverage (less than 25%). None of these samples are likely to work for our purposes. Instead, we will have to try a homologous gene from a closely-related taxon. In our first blastn search, samples labeled “D-hordein” showed up near the bottom of the results. A Google search suggests that D-hordein is a barley homolog to the wheat Glu-1 gene product. This might serve nicely as an outgroup. We will add 2 additional sequences to our list, for a total of 11: D82941.1, Hordeum vulgare (barley) D-hordein JX276655.1, Elymus sibiricus (Siberian wild rye) D-hordein "],["downloading-the-sequences-from-genbank.html", "Chapter 9 Downloading the sequences from GenBank 9.1 The DNA.bin object 9.2 The fasta format", " Chapter 9 Downloading the sequences from GenBank Now that we have identified the sequences for our tree, we need to download those sequences from GenBank into R. One option is to download the sequences directly from GenBank as a fasta file. If you are interested in this option, here is a good tutorial on how to do it. This will work and the subsequent fasta file can be uploaded into R. 9.1 The DNA.bin object However, the library ape has a command that allows us to download sequences from GenBank directly into R and store the sequences as a DNA.bin object. This is a data structure that stores information like DNA sequence, how long each sequence is, information about the species identification of each sequence, and the total base percentages of all the sequences. The command we’re using is read.GenBank, which takes an argument of the accession number we want to download from GenBank. Since we want to download multiple sequences, We use c(““) to concatenate a string of accession numbers that read.Genbank will interpret. library(ape) #if you haven&#39;t previously loaded ape read.GenBank(c(&quot;JX915632&quot;,&quot;EF105403.1&quot;,&quot;DQ073553.1&quot;, &quot;FJ481575.1&quot;,&quot;EF204545.1&quot;,&quot;AJ314771.1&quot;,&quot;FJ481569.1&quot;, &quot;DQ073533.1&quot;,&quot;AY804128.1&quot;,&quot;AY303125.2&quot;,&quot;KF887414.1&quot;, &quot;D82941.1&quot;,&quot;JX276655.1&quot;)) ## 13 DNA sequences in binary format stored in a list. ## ## Mean sequence length: 1814.385 ## Shortest sequence: 1476 ## Longest sequence: 2490 ## ## Labels: ## JX915632 ## EF105403.1 ## DQ073553.1 ## FJ481575.1 ## EF204545.1 ## AJ314771.1 ## ... ## ## Base composition: ## a c g t ## 0.310 0.303 0.271 0.115 ## (Total: 23.59 kb) Now that you have seen what read.Genbank does, we will save it as an object, and also specify that we want the sequences in ATGC form. When as.character=TRUE is not included (like above), read.GenBank saves all the sequence data in a binary format. Binary is great for computers, but harder for humans to quickly interpret. grass &lt;- read.GenBank(c(&quot;JX915632&quot;,&quot;EF105403.1&quot;,&quot;DQ073553.1&quot;, &quot;FJ481575.1&quot;,&quot;EF204545.1&quot;,&quot;AJ314771.1&quot;,&quot;FJ481569.1&quot;, &quot;DQ073533.1&quot;,&quot;AY804128.1&quot;,&quot;AY303125.2&quot;,&quot;KF887414.1&quot;, &quot;D82941.1&quot;,&quot;JX276655.1&quot;)) R BASICS In R, you can do two things with the output of a command. First, you can have the output displayed immediately. This is what you did in the first block of R code above. This can be really helpful if you want to immediately see what your command did, but it’s less helpful if you want to do something with the output. In the first block of code, we managed to download sequences from GenBank and print them to the screen, but we don’t have a way to build trees from the printed screen. (Print in this case refers to the display you see on the R console.) Second, you can tell R to save the output as an object. This is what we did second block of code with grass &lt;- read.GenBank. The &lt;- operator tells R to redirect the output from read.GenBank to an object (or data structure) named grass. Everything you saw printed on the screen from the first block of code is now saved to grass. If we ever want to see what objects we have saved in our R session, we can do so by typing the command ls() This tells R to list objects. We can see what each object contains by either typing the name of the object or by using the str (structure) command. The syntax of the structure command is str(object_name) 9.2 The fasta format While ape and related R packages have no difficulty interpreting a DNA.bin object, other programs need the data in the fasta format. Fasta is a really common format for saving bioinformatic data (probably the most common format used!). The format itself is quite simple and consists of two lines. The first line is the header line, which starts with &gt;, immediately followed by a unique identifier. The sequence itself is on the second line. The sequence can either the standard IUPAC nucleic acid or amino acid codes, with additional characters for gaps (-), uracil (U), or translation stops (*). The first 60 nucleotides from the Triticum aestivium sequence from above might look like this in fasta format: JX915632_Triticum_aestivium atggctaagcggctggtcctctttgcagcagtagccgtcgccctcgtggctctcaccgcc We can convert and save our DNA.bin object in fasta format using a tool from the ape package. The write.dna commands takes three arguments: the first argument tells R the DNA.bin file to use, the second argument says what to name the new file, and the third argument says what format to use for the new file. write.dna( grass, file = &#39;grass.fasta&#39;, format = &#39;fasta&#39; ) If you check your RStudio files (on the lower left side of the screen, you’ll see a tab named Files), you should see a newly-created file called “grass.fasta”. If you open it up, the file will look something like this: Going forward, we will use both the DNA.bin object and the fasta file. R BASICS You might have noticed that we didn’t save the output of write.dna to an object. That’s because any of the write commands are automatically saving the output to a file on your computer (or, on AnVIL, to your persistent disk). The output is saved in what as known as your working directory. You can check what your current working directory is during any R session with the command getwd() sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] ape_5.7-1 ## ## loaded via a namespace (and not attached): ## [1] sass_0.4.8 utf8_1.2.4 generics_0.1.3 xml2_1.3.6 ## [5] lattice_0.21-9 stringi_1.8.3 hms_1.1.3 digest_0.6.34 ## [9] magrittr_2.0.3 grid_4.3.2 evaluate_0.23 timechange_0.3.0 ## [13] bookdown_0.41 fastmap_1.1.1 rprojroot_2.0.4 jsonlite_1.8.8 ## [17] processx_3.8.3 chromote_0.3.1 ps_1.7.6 promises_1.2.1 ## [21] httr_1.4.7 fansi_1.0.6 ottrpal_1.3.0 jquerylib_0.1.4 ## [25] cli_3.6.2 rlang_1.1.4 cachem_1.0.8 yaml_2.3.8 ## [29] parallel_4.3.2 tools_4.3.2 tzdb_0.4.0 dplyr_1.1.4 ## [33] vctrs_0.6.5 R6_2.5.1 lifecycle_1.0.4 lubridate_1.9.3 ## [37] snakecase_0.11.1 stringr_1.5.1 janitor_2.2.0 pkgconfig_2.0.3 ## [41] pillar_1.9.0 bslib_0.6.1 later_1.3.2 glue_1.7.0 ## [45] Rcpp_1.0.12 xfun_0.48 tibble_3.2.1 tidyselect_1.2.0 ## [49] knitr_1.48 nlme_3.1-164 htmltools_0.5.7 websocket_1.4.2 ## [53] rmarkdown_2.25 webshot2_0.1.1 readr_2.1.5 compiler_4.3.2 ## [57] askpass_1.2.0 openssl_2.1.1 "],["why-do-we-align-sequences.html", "Chapter 10 Why do we align sequences?", " Chapter 10 Why do we align sequences? Sequence alignment is the art of lining up sequences from different samples in such a way that that reflects shared quality. When we perform an alignment in preparation for phylogenetic analyses, we aim to line up our sequences so that the complete alignment reflects the evolutionary relationships among all the samples. When we look at it, this mean that long stretches of the sequences should be fairly similar, with smaller regions of dissimilarity scattered throughout. As the samples become more distantly related from each other, the regions of similarity will become smaller and the regions of dissimilarity will become larger. How the regions of dissimilarity are arranged can change, depending on our choices of assumptions. All alignment programs will assign a “price” to each potential alignment the create, then return the least costly alignment as the final result. Most programs create potential alignments using an algorithm that assigns similarity scores to each pairwise comparison. The program then uses these scores to determine the final potential alignment. The algorithm also assigns penalties for alignments that include undesireable features. In general, an alignment algorithm can apply two major costs: gap opening cost: we can apply a penalty for opening (or starting) any gap (indicating an insertion or deletion event) gap extension cost: we can apply a penalty for making a gap longer Alignments can be created using either the nucleotide sequence or the amino acid sequence. Amino acid sequences can be useful when dealing with more diverse samples where the nucleotide sequence includes lots of regions of dissimilarity and few regions of similarity. Because there are only 4 nucleotides, compared to 20 amino acids, amino acid sequence alignments tend to be less noisy than nucleotide sequence alignments. Amino acid sequences are also slower to change than nucleotide sequences due silent (or synonymous) nucleotide mutations that don’t affect the amino acid sequence. Keep in mind that any alignment we use is still just a hypothesis - it may be a well-supported hypothesis that represents our best knowledge, but it may still not be correct. We may never know what the “true” alignment is. "],["creating-a-multiple-sequence-alignment.html", "Chapter 11 Creating a multiple sequence alignment 11.1 Installing the DECIPHER package 11.2 Loading the fasta file 11.3 Creating an alignment", " Chapter 11 Creating a multiple sequence alignment There are several packages available now for performing alignments in R, include ape (which we have used before), Biostrings, and mas. Each of these have their own strengths, and all of them will produce a good alignment. There are also many non-R-based alignment programs. For this class, we will focus on how to use the DECIPHER package, which will allow us to create an alignment, as well as look at it. If you would like to learn more about DECIPHER, you can find the manuals and specific examples (vignettes) here, the the Documentation section. 11.1 Installing the DECIPHER package DECIPHER is available via Bioconductor, which means we can install it using the AnVIL::install command. After we install the package, we can then open it via the library() command. (If you are prompted to update dependent packages, choose “all”.) #AnVIL::install(&#39;DECIPHER&#39;) #use this command to install the DECIPHER package library(DECIPHER) 11.2 Loading the fasta file DECIPHER’s commands use a fasta file as their input. We could load the fasta file directly into one of the commands, or we could load the fasta file into an object that we then pass to the commands. The second option gives us more flexibility and ultimately ends up saving time - we can load the file once and use it for multiple calculations. We are loading the fasta object we created and saved in our working directory last time. If the fasta file isn’t in your working directory, that’s okay - you can replace “grass.fasta” with the path to the directory in which it’s saved, followed by the file name. fas &lt;- &quot;grass.fasta&quot; 11.3 Creating an alignment DECIPHER lets us create alignments in a couple of ways, since we downloaded sequence from a protein-coding gene (Glu-1). We can align the sequences directly, or we can have the program translate the DNA sequences into amino acid sequences, then align the amino acid sequences. If the sequences you want to align are not protein-coding, then you can only align the sequences directly. This part has a couple of steps. First, pass the fasta file into an object formatted as a DNAStringSet object using the command readDNAStringSet. dna &lt;- readDNAStringSet(fas) dna ## DNAStringSet object of length 13: ## width seq names ## [1] 1521 ATGGCTAAGCGGCTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG JX915632 ## [2] 1506 ATGGCTAAGCGGTTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG EF105403.1 ## [3] 1506 ATGGCTAAGCGGCTGGTCCTCTT...ATTGTCGGCTAGCCAGTGATAG DQ073553.1 ## [4] 1749 ATGGCTAAGCGGTTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG FJ481575.1 ## [5] 2100 ATGGCTAAGCGGTTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG EF204545.1 ## ... ... ... ## [9] 2052 ATGGCTAAGCGACTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG AY804128.1 ## [10] 1650 ATGGCTAAGCGGTTGGTCCTCTT...ATTGTCGGCCAGCCAGTGATAG AY303125.2 ## [11] 1665 TCATCACCCACAACACCGAGCAC...CGCATTGTCGGCCAGCCAGTGA KF887414.1 ## [12] 2296 CAAAACTAGAGATCAATTCATTG...AAAACGGAAAGCTTCTCCATCC D82941.1 ## [13] 2046 ATGGCTAAGCAGCTGGTCCTCTT...CTCCCTGTCGGCCAGCCAGTAG JX276655.1 (You might have noticed a warning message about an invalid character type. Sometimes this happens when you download data from GenBank, because people may have made a mistake in the nucleotide sequence when they submitted their samples. Since it is only one base (and the sequences themselves are at least 1500 bp long), so excluding it is unlikely to bias our results.) Although it might look like the sequences are aligned in the DNAStringSet object, they really aren’t. To do so requires another command. First, let’s align our sequences using just the nucleotides. DNA.no_trans &lt;- AlignSeqs(dna) ## Determining distance matrix based on shared 10-mers: ## ================================================================================ ## ## Time difference of 0.01 secs ## ## Clustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Aligning Sequences: ## ================================================================================ ## ## Time difference of 0.4 secs ## ## Iteration 1 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.77 secs ## ## Iteration 2 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.75 secs ## ## Refining the alignment: ## ================================================================================ ## ## Time difference of 0.8 secs We can also align our sequences after they are first translated. The translated amino acids are aligned, and then the sequences is reverse-translated back to nucleotides. DNA.trans &lt;- AlignTranslation(dna) ## Determining distance matrix based on shared 5-mers: ## ================================================================================ ## ## Time difference of 0 secs ## ## Clustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Aligning Sequences: ## ================================================================================ ## ## Time difference of 0.18 secs ## ## Iteration 1 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.16 secs ## ## Iteration 2 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.17 secs Translating the nucleotide sequences sped up the alignment process, although both were fast enough it isn’t a big deal to directly align the nucleotides. Your choice of which alignment procedure to use will largely come down to whether you are using coding sequence and how divergent your samples are. If you aren’t using coding sequence, you will need to align using the nucleotides. If you have samples from deeply divergent species (especially if they come from different phyla), you will generally get a better alignment if you let the program translate your nucleotide sequence to amino acids first. Now that we’ve created alignments, it would be helpful to visually check them. (This is possible if your sequences aren’t too long, but can become really hard once you start dealing with very long stretches of DNA!) The BrowseSeqs command opens a browser window with the aligned sequences. Just remember which window belongs to each alignment! BrowseSeqs(DNA.no_trans) BrowseSeqs(DNA.trans) You can scroll through the browser windows to see the full alignment. DECIPHER automatically color-codes the nucleotides, which makes it easier to pick out when a sequence doesn’t match the others. At the very bottom, DECIPHER displays a consensus sequence, which we can also look at to identify which bases have mutations (or gaps). The first thing that jumps out it how the two alignment methods resulted in alignments of different lengths. The alignment from the AlignTranslation method is longer than the alignment from the AlignSeqs method. How the gaps are inserted also differ quite a bit. At this point, the alignment we choose to use is basically a judgment call. You have to decide which alignment seems “better” to you. With the grass sequences, sample AJ314771.1 doesn’t quite seem to fit well with the AlignTranslation alignment. There are long stretches of the sequence that aren’t aligned with anything else. This doesn’t seem to be the case for the AlignSeqs alignment. If we chose to go ahead with the AlignTranslation alignment, it would make sense to remove sample AJ314771.1 from our fasta file. You may come across a situation where one (or more) sequences don’t seem to fit very well with the others. The best option going forward is to remove those sequences, as keeping them will cause issues when it comes time to infer the phylogeny. The alignSeqs command allows us to change the gap opening and gap extension penalties. The default setting (which we used above, since we did not specify anything in the alignSeqs or alignTranslation commands) is to assign a minimum and maximum cost for each. For gap opening, the cost is -18 for nearly identical sequences and -14 for sequences that are more distantly related. For gap extension, those costs are -3 and -2. Let’s see what happens when we change the costs. DNA.no_trans.1 &lt;- AlignSeqs(dna, gapOpening = c(-20, -10), gapExtension = c(-5, -1)) ## Determining distance matrix based on shared 10-mers: ## ================================================================================ ## ## Time difference of 0.01 secs ## ## Clustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Aligning Sequences: ## ================================================================================ ## ## Time difference of 0.3 secs ## ## Iteration 1 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.63 secs ## ## Iteration 2 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.56 secs ## ## Refining the alignment: ## ================================================================================ ## ## Time difference of 0.45 secs BrowseSeqs(DNA.no_trans.1) Changing the gap opening and gap extension costs may or may not make a difference. In many cases, the default parameters will work just fine. However, it is always wise to check additional values! For the grass samples, it would be reasonable to use the alignment generated by the AlignSeqs method. This is a judgment call more than anything else - there are large sections of the alignment that include all the sequences with minimal changes. We’ll want to trim it to remove the ends with very little sequence coverage. We will keep everything between base 140 and 3373. To trim the sequences, we will write a new fasta file, then use it to create a new DNAbin object. If you haven’t already loaded the ape library in your R session, you should do so now using the library(ape) command. writeXStringSet(DNA.no_trans, file=&quot;grass_aligned.fasta&quot;) grass.align &lt;- read.dna(&quot;grass_aligned.fasta&quot;, format=&quot;fasta&quot;, as.matrix=TRUE) The trick for this step is that we specified the grass.align object be loaded as a matrix, not as a list. We can subset our sequences using brackets since grass.align is in matrix format. grass.trimmed &lt;- grass.align[,140:3373] grass.trimmed ## 13 DNA sequences in binary format stored in a matrix. ## ## All sequences of same length: 3234 ## ## Labels: ## JX915632 ## EF105403.1 ## DQ073553.1 ## FJ481575.1 ## EF204545.1 ## AJ314771.1 ## ... ## ## Base composition: ## a c g t ## 0.316 0.303 0.268 0.113 ## (Total: 42.04 kb) Congratulations! You now have a trimmed alignment, ready for inferring trees. To be on the safe side, we will save it as a fasta file. write.dna( grass.align, file = &#39;grass_aligned.fasta&#39;, format = &#39;fasta&#39; ) R BASICS R has both data types and data structures. Data types (like character (for letters) or numeric (for real or decimal numbers)) can be combined to form data structures. Some of the data structures include: vector list matrix data frame The data structures differ based on their size and what data types they can accept. A vector is a single dimension collection of one data type. You can have vectors made up of many character data types or many numerical data types, but you can’t have a vector of both character and numerical data types together. For example, a vector of numeric data might look like this: 1 1 2 3 5 DNAbin objects are normally formatted as lists, which can be thought of as a multidimensional collection of vectors where each vector can be of a different type. (Within a vector everything is still a single character type.) In the code above, we specified the DNAbin object be formatted as a matrix. The matrix data structure is basically vectors in more than one dimensional, which means all the elements within a matrix must be the same data type (in this case, everything was a character). A matrix of numeric data like the vector example above might look like this: [,1] [,2] [,3] [,4] [,5] [1,] 1 1 2 3 5 [2,] 2 3 5 7 11 In a matrix (as well as in a data frame, which we haven’t discussed), the position of an entry can be specificed using brackets. The first coordinate in the bracket indicates the row, while the second coordinate indicates the column. For the matrix above, [2,5] points to the number 11, which is the entry in the second row and fifth column. If we want to point to an entire row, we can leave off the second coordinate. [1,] points to the entire first row. If we want to point to an entire column, we have two choices. We could use either [,1] or just [1]. R will interpret both of those commands as pointing to column 1. By making the DNAbin object a matrix, we could subset it like a matrix. That’s what we did with the brackets. grass.align[,140:3373] The comma at the beginning of the bracket told R that we wanted to keep all the rows in the matrix grass.align. The 140:3373 told R to keep all the columns between column 140 and column 3372 (as well as those two columns). If we had chosen to remove one of our samples (let’s say, the third sample), we could use the brackets to do so as well. The command for that would look like: kept.sequences &lt;- grass.align[c(1:2,4:13),] The c(1:2,4:13) is telling R that we want to keep all the sequences between the 1st and 2nd rows, as well as all the sequences between the 4th and 13th row. We have to use the c() syntax because we have two sets of rows to keep. sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] DECIPHER_2.30.0 RSQLite_2.3.5 Biostrings_2.70.3 ## [4] GenomeInfoDb_1.38.8 XVector_0.42.0 IRanges_2.36.0 ## [7] S4Vectors_0.40.2 BiocGenerics_0.48.1 BiocManager_1.30.22 ## [10] ape_5.7-1 ## ## loaded via a namespace (and not attached): ## [1] xfun_0.48 bslib_0.6.1 websocket_1.4.2 ## [4] processx_3.8.3 lattice_0.21-9 tzdb_0.4.0 ## [7] vctrs_0.6.5 tools_4.3.2 ps_1.7.6 ## [10] bitops_1.0-9 generics_0.1.3 tibble_3.2.1 ## [13] fansi_1.0.6 blob_1.2.4 pkgconfig_2.0.3 ## [16] lifecycle_1.0.4 GenomeInfoDbData_1.2.11 compiler_4.3.2 ## [19] stringr_1.5.1 chromote_0.3.1 janitor_2.2.0 ## [22] snakecase_0.11.1 htmltools_0.5.7 sass_0.4.8 ## [25] RCurl_1.98-1.14 yaml_2.3.8 crayon_1.5.2 ## [28] later_1.3.2 pillar_1.9.0 jquerylib_0.1.4 ## [31] openssl_2.1.1 cachem_1.0.8 nlme_3.1-164 ## [34] webshot2_0.1.1 tidyselect_1.2.0 ottrpal_1.3.0 ## [37] digest_0.6.34 stringi_1.8.3 dplyr_1.1.4 ## [40] bookdown_0.41 rprojroot_2.0.4 fastmap_1.1.1 ## [43] grid_4.3.2 cli_3.6.2 magrittr_2.0.3 ## [46] utf8_1.2.4 readr_2.1.5 promises_1.2.1 ## [49] bit64_4.0.5 lubridate_1.9.3 timechange_0.3.0 ## [52] rmarkdown_2.25 httr_1.4.7 bit_4.0.5 ## [55] askpass_1.2.0 hms_1.1.3 memoise_2.0.1 ## [58] evaluate_0.23 knitr_1.48 rlang_1.1.4 ## [61] Rcpp_1.0.12 DBI_1.2.2 glue_1.7.0 ## [64] xml2_1.3.6 jsonlite_1.8.8 R6_2.5.1 ## [67] zlibbioc_1.48.2 "],["the-neighbor-joining-method-of-tree-estimation.html", "Chapter 12 The neighbor joining method of tree estimation 12.1 Models of molecular evolution", " Chapter 12 The neighbor joining method of tree estimation There are two basic types of tree estimation methods: distance methods (which includes neighbor joining, discussed here) and tree-searching methods (which we will cover in later sections). The first phylogenetic trees were built using distance methods. Strictly speaking, these methods can be considered phenetic methods, not phylogenetic methods, since these methods group taxa based on similarity instead of attempting to find the most likely tree. For all practical purposes, though, we can include neighbor joining in under the umbrella of phylogenetics. In distance-based methods like neighbor joining, the genetic data is converted into a distance matrix, which is used to group taxa based on the genetic distance between them. Neighbor joining specifically works via star decomposition. Let’s take a look at an example (adapted from (Fred Opperdoes)[http://www.deduveinstitute.be/~opperd/private/neighbor.html]). We have 5 taxa (A,B,C,D, and E) for which we would like to infer a phylogeny. We’ve calculated the following distances among all the taxa: The shortest distance between any taxa is 13, which means that A and B are most closely related to each other and will form our first group. We begin with all the taxa forming a star shape, and then we add a branch that connects A and B. We keep grouping taxa until the entire star has been resolved into bifurcating branches (nodes that connect two, and only two, branches). For our example tree, we eventually end up with this tree: The neighbor joining method is very fast, requires very few computational resources, and is statistically consistent. It will also always result in only a single tree topology. Unfortunately, many people will become overly confident that the single neighbor joining tree is the true tree, which is not necessarily true. Nowadays, most researchers might start their analysis with a neighbor joining tree, but they generally go on to infer trees using one of the other methods. There is another type of distance method you might hear about called UPGMA (unweighted pair group method with arithmetic mean). This is a hierarchical clustering method. However, the tree built using UPGMA depends greatly on the order in which the taxa are added, unlike the neighbor joining method (which will result in the same tree no matter what order the samples are added). As a result, the UPGMA method is almost never used in phylogenetics today. 12.1 Models of molecular evolution In the example above, we kind of glossed over the process of converting DNA sequence into genetic distances. In its simplest form, every mutation is given a value, and the total value of all mutations is then used to calculate a genetic distance. But wait, you might be thinking. How do researchers decide what value to assign each mutation? Are all mutations given the same value, or do some changes “cost” more than others? Aren’t some mutations considered more unlikely than others? These are all excellent questions that should be considered whenever dealing with phylogenetic analysis. Luckily, we don’t have to answer all these questions ourselves. Instead, we can look at published models of molecular evolution (also called substitution models) and decide which model fits our data the best. 12.1.1 JC69 A model of molecular evolution is a set of rules that determines how much each mutation costs relative to all other mutations. One of the earliest published models is the JC69 model (sometimes written as JC), proposed by Jukes and Cantor in 1969. The JC69 model assumes equal base frequencies (that is, each nucleotide makes up 25% of the bases in the DNA sequence), as well as equal mutation rates. A mutation of an A to a T is the same as the mutation as a T to an A or an A to a C. As a result, the JC69 model has only 1 parameter - the mutation rate. 12.1.2 K2P Many other models of molecular evolution have been published since JC69. One of the more popular ones is the Kimura two-parameter model (also called K80, or K2P). This model still assumes equal base frequencies, but allows for a distinct mutation rate for transitions (mutations between purines or pyrimidines) and a different mutation rate for tranversions (mutations from purine to pyrimidine, or vice versa). As you might have guessed from the name, this particular model has two parameters. 12.1.3 GTR One of the most complex models you might come across is the general time reversible model, or GTR. This model is extremely flexible but also parameter-heavy. There are no assumptions about base frequencies, and each possible mutation is given its own mutation rate. (A quick note: the mutation rate from A to G is the same as the mutation rate from G to A in this model.) As a result, this model has 9 parameters: 6 mutation rates + 3 base frequencies. (Because the sum of the 4 base frequencies must equal 1, we only have to describe 3 of them in order to calculate all 4. That’s why we only need 3 parameters to model the base frequencies for GTR.) 12.1.4 Other parameters Sometimes you will run across a model that has “+ I” added to it (like GTR + I). The “I” refers to a invariant sites parameter. In these models, each base has a certain probability of being invariate, or unlikely to mutate. Another option you might see is using a gamma distribution to estimate how many times any given base in a sequence might mutate. We often think of mutation as a one-and-done process, where a nucleotide might mutate only once. This isn’t a bad assumption; in fact, given that mutation is so rare, it is extremely unlikely for a nucleotide to mutate multiple times, though it does happen (particularly as divergence times between taxa increase). A solution to this dilemma is to include a parameter that describes how many times a particular nucleotide has undergone mutation. A gamma distribution is used because the highest probability is found in the smallest values of x, with a low probability of larger values of x (which would be multiple mutation hits at the same nucleotide). A model using a gamma distribution with have a “+ G”. Finally, some models with have a “+ SS” added to it. The SS indicates a site-specific variation parameter. These models will estimate different mutation rates for each codon position. Site-specific models are much less common than models that include invariate sites parameters or a $ parameter. 12.1.5 How do I choose a model? There are enough substitution models out there that it can be a bit overwhelming to pick one for your phylogenetic analyses. (The models discussed above are in no way an exhaustive list.) Many researchers will have a favorite model they use, while others will rely model test programs to tell them which model of molecular evolution best fits their data. Although GTR + I + $ might be the most biologically realistic model, it is also parameter-heavy and may not be the best choice when dealing with a sequence alignment that includes only a small number of phylogenetically-informative sites. ## Determining distance matrix based on shared 10-mers: ## ================================================================================ ## ## Time difference of 0.01 secs ## ## Clustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Aligning Sequences: ## ================================================================================ ## ## Time difference of 0.32 secs ## ## Iteration 1 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.56 secs ## ## Iteration 2 of 2: ## ## Determining distance matrix based on alignment: ## ================================================================================ ## ## Time difference of 0 secs ## ## Reclustering into groups by similarity: ## ================================================================================ ## ## Time difference of 0 secs ## ## Realigning Sequences: ## ================================================================================ ## ## Time difference of 0.76 secs ## ## Refining the alignment: ## ================================================================================ ## ## Time difference of 0.82 secs "],["building-a-neighbor-joining-tree.html", "Chapter 13 Building a neighbor joining tree 13.1 The phyDat object 13.2 Choosing a substitution model 13.3 Building the neighbor joining tree 13.4 Visualizing the neighbor joining tree 13.5 Saving your trees", " Chapter 13 Building a neighbor joining tree We are finally ready to start building trees from our data. For these analyses, we will use an R package called phangorn. If you’d like to learn more about it, you can find the manual here. phangorn (Phylogenetic Reconstruction and Analysis) is stored in the CRAN repository, so we will use install.packages for the installation. install.packages(&#39;phangorn&#39;) library(phangorn) 13.1 The phyDat object phangorn uses a data structure called phyDat to store information. You can either load the fasta file of your alignment into a phyDat object, or you can directly convert the DNAbin object of your alignment into a phyDat object. You will also want to make sure you have access to your DNAbin object, since we will need that for the model testing. #Loading a fasta file grass.phy &lt;- read.phyDat(&#39;grass_aligned.fasta&#39;, format = &#39;fasta&#39;, type = &#39;DNA&#39;) #Converting your DNAbin object grass.align &lt;- read.dna(&#39;grass_aligned.fasta&#39;, format = &#39;fasta&#39;) grass.phy &lt;- phyDat(grass.align) grass.phy ## 13 sequences with 3585 character and 1119 different site patterns. ## The states are a c g t The phyDat object is remarkably similar to the DNAbin object - this isn’t too surprising, since the same team wrote both ape and phangorn. R BASICS If you are pausing your R environment on AnVIL (or have not closed an R session), you may still have all the objects you created previously still available. To check this, you can use the list command. ls() R will print all the objects that are still stored in the workspace. If you see your aligned DNAbin object (which can also bee seen in the Environment tab in the upper right box of RStudio), you can directly convert it to a phyDat object instead of loading the fasta file first. 13.2 Choosing a substitution model phangorn can test our data against 24 different substitution models to determine which is the best fit. We first have to create a “guide” tree. (In future releases of phangorn creating this tree won’t be necessary, but for now it doesn’t take much extra time to create a tree.) dist.matrix &lt;- dist.dna(grass.align) dist.matrix ## JX915632 EF105403.1 DQ073553.1 FJ481575.1 EF204545.1 AJ314771.1 ## EF105403.1 0.01221062 ## DQ073553.1 0.01219682 0.00973376 ## FJ481575.1 0.04758637 0.05285651 0.05546604 ## EF204545.1 0.05963432 0.06233338 0.06498304 0.05007086 ## AJ314771.1 0.08255861 0.08255861 0.08248480 0.09450600 0.09638394 ## FJ481569.1 0.06970732 0.07241003 0.07372738 0.08309250 0.09702098 0.11833578 ## DQ073533.1 0.09773107 0.09630046 0.09764817 0.11151055 0.11461596 0.14259807 ## AY804128.1 0.07268933 0.08095398 0.07950470 0.08464979 0.10731656 0.12910195 ## AY303125.2 0.13551646 0.13398741 0.13386896 0.15627157 0.16453062 0.17201317 ## KF887414.1 0.10204765 0.10349483 0.10340362 0.11297040 0.13258196 0.14259807 ## D82941.1 0.21452588 0.22149463 0.21782031 0.22708927 0.24902239 0.25144294 ## JX276655.1 0.20798301 0.21661880 0.21297096 0.22392751 0.23671033 0.24274355 ## FJ481569.1 DQ073533.1 AY804128.1 AY303125.2 KF887414.1 D82941.1 ## EF105403.1 ## DQ073553.1 ## FJ481575.1 ## EF204545.1 ## AJ314771.1 ## FJ481569.1 ## DQ073533.1 0.11388614 ## AY804128.1 0.08065836 0.13011175 ## AY303125.2 0.14786836 0.11333554 0.16513852 ## KF887414.1 0.10968116 0.11385297 0.13050488 0.11776689 ## D82941.1 0.22628374 0.23078837 0.23717769 0.25882315 0.23332142 ## JX276655.1 0.21794455 0.24374554 0.24113161 0.25554132 0.22798329 0.11452388 str(dist.matrix) ## &#39;dist&#39; num [1:78] 0.0122 0.0122 0.0476 0.0596 0.0826 ... ## - attr(*, &quot;Size&quot;)= int 13 ## - attr(*, &quot;Labels&quot;)= chr [1:13] &quot;JX915632&quot; &quot;EF105403.1&quot; &quot;DQ073553.1&quot; &quot;FJ481575.1&quot; ... ## - attr(*, &quot;Upper&quot;)= logi FALSE ## - attr(*, &quot;Diag&quot;)= logi FALSE ## - attr(*, &quot;call&quot;)= language dist.dna(x = grass.align) ## - attr(*, &quot;method&quot;)= chr &quot;K80&quot; The distance matrix stores all the distances in the lower half of the table to save space. This particular matrix used the K80 model (also known as the K2P model) to calculate the distances. When we use the str(dist.matrix) command, we can see the model used stored in the method attribute. Next, we make a very quick neighbor joining tree to act as the guide tree. We then run the model test command using our phyDat object and the guide tree. tree.guide &lt;- NJ(dist.matrix) mod.test &lt;- modelTest(grass.phy, tree = tree.guide) ## Model df logLik AIC BIC ## JC 23 -12485.95 25017.89 25160.14 ## JC+I 24 -12450.63 24949.26 25097.69 ## JC+G(4) 24 -12440.6 24929.19 25077.62 ## JC+G(4)+I 25 -12440.6 24931.19 25085.8 ## F81 26 -12282.14 24616.28 24777.08 ## F81+I 27 -12246.41 24546.83 24713.81 ## F81+G(4) 27 -12235.56 24525.12 24692.1 ## F81+G(4)+I 28 -12235.56 24527.12 24700.29 ## K80 24 -12259.35 24566.7 24715.13 ## K80+I 25 -12215.84 24481.69 24636.3 ## K80+G(4) 25 -12203.6 24457.2 24611.81 ## K80+G(4)+I 26 -12203.6 24459.2 24620 ## HKY 27 -12048.85 24151.7 24318.68 ## HKY+I 28 -12005.72 24067.43 24240.6 ## HKY+G(4) 28 -11992.71 24041.43 24214.59 ## HKY+G(4)+I 29 -11992.71 24043.43 24222.78 ## TrNe 25 -12253.31 24556.62 24711.23 ## TrNe+I 26 -12210.56 24473.12 24633.91 ## TrNe+G(4) 26 -12198.44 24448.89 24609.69 ## TrNe+G(4)+I 27 -12198.44 24450.89 24617.87 ## TrN 28 -12042.97 24141.94 24315.1 ## TrN+I 29 -11997.85 24053.69 24233.05 ## TrN+G(4) 29 -11984.41 24026.83 24206.18 ## TrN+G(4)+I 30 -11984.41 24028.83 24214.36 ## TPM1 25 -12258.47 24566.93 24721.54 ## TPM1+I 26 -12215.02 24482.03 24642.83 ## TPM1+G(4) 26 -12202.72 24457.45 24618.25 ## TPM1+G(4)+I 27 -12202.73 24459.45 24626.43 ## K81 25 -12258.47 24566.93 24721.54 ## K81+I 26 -12215.02 24482.03 24642.83 ## K81+G(4) 26 -12202.72 24457.45 24618.25 ## K81+G(4)+I 27 -12202.73 24459.45 24626.43 ## TPM1u 28 -12048.78 24153.55 24326.72 ## TPM1u+I 29 -12005.59 24069.17 24248.52 ## TPM1u+G(4) 29 -11992.57 24043.14 24222.49 ## TPM1u+G(4)+I 30 -11992.57 24045.14 24230.68 ## TPM2 25 -12259 24567.99 24722.6 ## TPM2+I 26 -12215.81 24483.62 24644.42 ## TPM2+G(4) 26 -12203.6 24459.2 24619.99 ## TPM2+G(4)+I 27 -12203.6 24461.2 24628.18 ## TPM2u 28 -12046.75 24149.51 24322.67 ## TPM2u+I 29 -12004.37 24066.74 24246.09 ## TPM2u+G(4) 29 -11991.57 24041.14 24220.49 ## TPM2u+G(4)+I 30 -11991.57 24043.14 24228.67 ## TPM3 25 -12258.58 24567.15 24721.76 ## TPM3+I 26 -12215.04 24482.08 24642.88 ## TPM3+G(4) 26 -12202.72 24457.45 24618.25 ## TPM3+G(4)+I 27 -12202.73 24459.45 24626.43 ## TPM3u 28 -12038.58 24133.16 24306.33 ## TPM3u+I 29 -11991.92 24041.83 24221.18 ## TPM3u+G(4) 29 -11977.59 24013.17 24192.52 ## TPM3u+G(4)+I 30 -11977.59 24015.17 24200.71 ## TIM1e 26 -12252.42 24556.84 24717.64 ## TIM1e+I 27 -12209.72 24473.44 24640.43 ## TIM1e+G(4) 27 -12197.56 24449.12 24616.1 ## TIM1e+G(4)+I 28 -12197.56 24451.12 24624.29 ## TIM1 29 -12042.9 24143.81 24323.16 ## TIM1+I 30 -11997.73 24055.47 24241 ## TIM1+G(4) 30 -11984.28 24028.57 24214.1 ## TIM1+G(4)+I 31 -11984.28 24030.57 24222.29 ## TIM2e 26 -12252.94 24557.88 24718.68 ## TIM2e+I 27 -12210.53 24475.05 24642.03 ## TIM2e+G(4) 27 -12198.44 24450.89 24617.87 ## TIM2e+G(4)+I 28 -12198.44 24452.89 24626.05 ## TIM2 29 -12040.85 24139.7 24319.05 ## TIM2+I 30 -11996.5 24053 24238.53 ## TIM2+G(4) 30 -11983.33 24026.66 24212.2 ## TIM2+G(4)+I 31 -11983.33 24028.66 24220.38 ## TIM3e 26 -12252.45 24556.9 24717.69 ## TIM3e+I 27 -12209.76 24473.53 24640.51 ## TIM3e+G(4) 27 -12197.63 24449.26 24616.24 ## TIM3e+G(4)+I 28 -12197.63 24451.26 24624.43 ## TIM3 29 -12031.72 24121.44 24300.79 ## TIM3+I 30 -11981.48 24022.96 24208.5 ## TIM3+G(4) 30 -11966.21 23992.42 24177.95 ## TIM3+G(4)+I 31 -11966.21 23994.42 24186.14 ## TVMe 27 -12257.01 24568.02 24735.01 ## TVMe+I 28 -12214.03 24484.05 24657.22 ## TVMe+G(4) 28 -12201.77 24459.54 24632.71 ## TVMe+G(4)+I 29 -12201.77 24461.54 24640.89 ## TVM 30 -12035.58 24131.15 24316.69 ## TVM+I 31 -11989.78 24041.55 24233.27 ## TVM+G(4) 31 -11975.69 24013.38 24205.1 ## TVM+G(4)+I 32 -11975.69 24015.38 24213.29 ## SYM 28 -12250.86 24557.72 24730.89 ## SYM+I 29 -12208.75 24475.5 24654.85 ## SYM+G(4) 29 -12196.66 24451.33 24630.68 ## SYM+G(4)+I 30 -12196.66 24453.33 24638.86 ## GTR 31 -12028.68 24119.37 24311.09 ## GTR+I 32 -11979.34 24022.69 24220.59 ## GTR+G(4) 32 -11964.44 23992.87 24190.78 ## GTR+G(4)+I 33 -11964.44 23994.87 24198.96 As the model test runs, R prints out most of the models being tested. For some reason, R doesn’t print the basic models. The first three models listed are JC + I, JC + G, and JC + G + I. While these models are being tested, the program is also testing the basic JC model. mod.test ## Model df logLik AIC AICw AICc AICcw ## 1 JC 23 -12485.95 25017.89 8.521162e-224 25018.20 9.676258e-224 ## 2 JC+I 24 -12450.63 24949.26 6.831105e-209 24949.59 7.652882e-209 ## 3 JC+G(4) 24 -12440.60 24929.19 1.556172e-204 24929.53 1.743378e-204 ## 4 JC+G(4)+I 25 -12440.60 24931.19 5.723464e-205 24931.56 6.322241e-205 ## 5 F81 26 -12282.14 24616.28 1.379092e-136 24616.67 1.501191e-136 ## 6 F81+I 27 -12246.41 24546.83 1.665570e-121 24547.25 1.785617e-121 ## 7 F81+G(4) 27 -12235.56 24525.12 8.600271e-117 24525.55 9.220141e-117 ## 8 F81+G(4)+I 28 -12235.56 24527.12 3.163049e-117 24527.58 3.337844e-117 ## 9 K80 24 -12259.35 24566.70 8.059939e-126 24567.03 9.029544e-126 ## 10 K80+I 25 -12215.84 24481.69 2.320082e-107 24482.06 2.562804e-107 ## 11 K80+G(4) 25 -12203.60 24457.20 4.825924e-102 24457.56 5.330802e-102 ## 12 K80+G(4)+I 26 -12203.60 24459.20 1.774970e-102 24459.59 1.932118e-102 ## 13 HKY 27 -12048.85 24151.70 1.051483e-35 24152.13 1.127269e-35 ## 14 HKY+I 28 -12005.72 24067.43 2.092988e-17 24067.89 2.208650e-17 ## 15 HKY+G(4) 28 -11992.71 24041.43 9.280424e-12 24041.88 9.793276e-12 ## 16 HKY+G(4)+I 29 -11992.71 24043.43 3.413362e-12 24043.92 3.543472e-12 ## 17 TrNe 25 -12253.31 24556.62 1.242675e-123 24556.99 1.372681e-123 ## 18 TrNe+I 26 -12210.56 24473.12 1.687072e-105 24473.51 1.836438e-105 ## 19 TrNe+G(4) 26 -12198.44 24448.89 3.076287e-100 24449.28 3.348648e-100 ## 20 TrNe+G(4)+I 27 -12198.44 24450.89 1.131444e-100 24451.32 1.212994e-100 ## 21 TrN 28 -12042.97 24141.94 1.386096e-33 24142.39 1.462694e-33 ## 22 TrN+I 29 -11997.85 24053.69 2.011318e-14 24054.18 2.087985e-14 ## 23 TrN+G(4) 29 -11984.41 24026.83 1.373994e-08 24027.32 1.426368e-08 ## 24 TrN+G(4)+I 30 -11984.41 24028.83 5.053631e-09 24029.35 5.158084e-09 ## 25 TPM1 25 -12258.47 24566.93 7.174516e-126 24567.30 7.925100e-126 ## 26 TPM1+I 26 -12215.02 24482.03 1.956068e-107 24482.43 2.129250e-107 ## 27 TPM1+G(4) 26 -12202.72 24457.45 4.257453e-102 24457.84 4.634389e-102 ## 28 TPM1+G(4)+I 27 -12202.73 24459.45 1.565766e-102 24459.88 1.678619e-102 ## 29 K81 25 -12258.47 24566.93 7.174516e-126 24567.30 7.925100e-126 ## 30 K81+I 26 -12215.02 24482.03 1.956068e-107 24482.43 2.129250e-107 ## 31 K81+G(4) 26 -12202.72 24457.45 4.257453e-102 24457.84 4.634389e-102 ## 32 K81+G(4)+I 27 -12202.73 24459.45 1.565766e-102 24459.88 1.678619e-102 ## 33 TPM1u 28 -12048.78 24153.55 4.166546e-36 24154.01 4.396796e-36 ## 34 TPM1u+I 29 -12005.59 24069.17 8.755752e-18 24069.66 9.089504e-18 ## 35 TPM1u+G(4) 29 -11992.57 24043.14 3.934829e-12 24043.63 4.084817e-12 ## 36 TPM1u+G(4)+I 30 -11992.57 24045.14 1.447229e-12 24045.67 1.477142e-12 ## 37 TPM2 25 -12259.00 24567.99 4.219763e-126 24568.36 4.661226e-126 ## 38 TPM2+I 26 -12215.81 24483.62 8.822378e-108 24484.02 9.603473e-108 ## 39 TPM2+G(4) 26 -12203.60 24459.20 1.776912e-102 24459.59 1.934232e-102 ## 40 TPM2+G(4)+I 27 -12203.60 24461.20 6.535119e-103 24461.62 7.006141e-103 ## 41 TPM2u 28 -12046.75 24149.51 3.148425e-35 24149.96 3.322412e-35 ## 42 TPM2u+I 29 -12004.37 24066.74 2.954974e-17 24067.23 3.067612e-17 ## 43 TPM2u+G(4) 29 -11991.57 24041.14 1.072128e-11 24041.63 1.112996e-11 ## 44 TPM2u+G(4)+I 30 -11991.57 24043.14 3.942948e-12 24043.66 4.024444e-12 ## 45 TPM3 25 -12258.58 24567.15 6.427868e-126 24567.52 7.100339e-126 ## 46 TPM3+I 26 -12215.04 24482.08 1.910411e-107 24482.47 2.079550e-107 ## 47 TPM3+G(4) 26 -12202.72 24457.45 4.257475e-102 24457.84 4.634413e-102 ## 48 TPM3+G(4)+I 27 -12202.73 24459.45 1.565894e-102 24459.88 1.678757e-102 ## 49 TPM3u 28 -12038.58 24133.16 1.113837e-31 24133.62 1.175389e-31 ## 50 TPM3u+I 29 -11991.92 24041.83 7.573118e-12 24042.32 7.861790e-12 ## 51 TPM3u+G(4) 29 -11977.59 24013.17 1.267532e-05 24013.66 1.315848e-05 ## 52 TPM3u+G(4)+I 30 -11977.59 24015.17 4.661767e-06 24015.70 4.758120e-06 ## 53 TIM1e 26 -12252.42 24556.84 1.112058e-123 24557.24 1.210515e-123 ## 54 TIM1e+I 27 -12209.72 24473.44 1.431998e-105 24473.87 1.535210e-105 ## 55 TIM1e+G(4) 27 -12197.56 24449.12 2.737179e-100 24449.55 2.934463e-100 ## 56 TIM1e+G(4)+I 28 -12197.56 24451.12 1.006731e-100 24451.58 1.062365e-100 ## 57 TIM1 29 -12042.90 24143.81 5.445800e-34 24144.30 5.653383e-34 ## 58 TIM1+I 30 -11997.73 24055.47 8.282117e-15 24055.99 8.453299e-15 ## 59 TIM1+G(4) 30 -11984.28 24028.57 5.750601e-09 24029.09 5.869459e-09 ## 60 TIM1+G(4)+I 31 -11984.28 24030.57 2.115101e-09 24031.13 2.121317e-09 ## 61 TIM2e 26 -12252.94 24557.88 6.614142e-124 24558.28 7.199730e-124 ## 62 TIM2e+I 27 -12210.53 24475.05 6.407431e-106 24475.48 6.869250e-106 ## 63 TIM2e+G(4) 27 -12198.44 24450.89 1.133467e-100 24451.31 1.215162e-100 ## 64 TIM2e+G(4)+I 28 -12198.44 24452.89 4.168896e-101 24453.34 4.399276e-101 ## 65 TIM2 29 -12040.85 24139.70 4.235978e-33 24140.19 4.397445e-33 ## 66 TIM2+I 30 -11996.50 24053.00 2.852468e-14 24053.52 2.911425e-14 ## 67 TIM2+G(4) 30 -11983.33 24026.66 1.492272e-08 24027.18 1.523116e-08 ## 68 TIM2+G(4)+I 31 -11983.33 24028.66 5.488017e-09 24029.22 5.504145e-09 ## 69 TIM3e 26 -12252.45 24556.90 1.083356e-123 24557.29 1.179272e-123 ## 70 TIM3e+I 27 -12209.76 24473.53 1.372620e-105 24473.95 1.471552e-105 ## 71 TIM3e+G(4) 27 -12197.63 24449.26 2.553916e-100 24449.69 2.737991e-100 ## 72 TIM3e+G(4)+I 28 -12197.63 24451.26 9.393268e-101 24451.72 9.912355e-101 ## 73 TIM3 29 -12031.72 24121.44 3.921543e-29 24121.93 4.071024e-29 ## 74 TIM3+I 30 -11981.48 24022.96 9.472061e-08 24023.49 9.667838e-08 ## 75 TIM3+G(4) 30 -11966.21 23992.42 4.067760e-01 23992.94 4.151836e-01 ## 76 TIM3+G(4)+I 31 -11966.21 23994.42 1.496128e-01 23994.98 1.500525e-01 ## 77 TVMe 27 -12257.01 24568.02 4.153847e-126 24568.45 4.453238e-126 ## 78 TVMe+I 28 -12214.03 24484.05 7.122920e-108 24484.51 7.516544e-108 ## 79 TVMe+G(4) 28 -12201.77 24459.54 1.494892e-102 24460.00 1.577503e-102 ## 80 TVMe+G(4)+I 29 -12201.77 24461.54 5.498279e-103 24462.03 5.707863e-103 ## 81 TVM 30 -12035.58 24131.15 3.048796e-31 24131.67 3.111811e-31 ## 82 TVM+I 31 -11989.78 24041.55 8.712514e-12 24042.11 8.738119e-12 ## 83 TVM+G(4) 31 -11975.69 24013.38 1.141540e-05 24013.94 1.144895e-05 ## 84 TVM+G(4)+I 32 -11975.69 24015.38 4.198219e-06 24015.98 4.135045e-06 ## 85 SYM 28 -12250.86 24557.72 7.173358e-124 24558.18 7.569770e-124 ## 86 SYM+I 29 -12208.75 24475.50 5.134112e-106 24475.99 5.329814e-106 ## 87 SYM+G(4) 29 -12196.66 24451.33 9.083953e-101 24451.82 9.430215e-101 ## 88 SYM+G(4)+I 30 -12196.66 24453.33 3.341115e-101 24453.85 3.410172e-101 ## 89 GTR 31 -12028.68 24119.37 1.102738e-28 24119.93 1.105978e-28 ## 90 GTR+I 32 -11979.34 24022.69 1.088435e-07 24023.28 1.072056e-07 ## 91 GTR+G(4) 32 -11964.44 23992.87 3.243035e-01 23993.47 3.194235e-01 ## 92 GTR+G(4)+I 33 -11964.44 23994.87 1.192745e-01 23995.50 1.153067e-01 ## BIC ## 1 25160.14 ## 2 25097.69 ## 3 25077.62 ## 4 25085.80 ## 5 24777.08 ## 6 24713.81 ## 7 24692.10 ## 8 24700.29 ## 9 24715.13 ## 10 24636.30 ## 11 24611.81 ## 12 24620.00 ## 13 24318.68 ## 14 24240.60 ## 15 24214.59 ## 16 24222.78 ## 17 24711.23 ## 18 24633.91 ## 19 24609.69 ## 20 24617.87 ## 21 24315.10 ## 22 24233.05 ## 23 24206.18 ## 24 24214.36 ## 25 24721.54 ## 26 24642.83 ## 27 24618.25 ## 28 24626.43 ## 29 24721.54 ## 30 24642.83 ## 31 24618.25 ## 32 24626.43 ## 33 24326.72 ## 34 24248.52 ## 35 24222.49 ## 36 24230.68 ## 37 24722.60 ## 38 24644.42 ## 39 24619.99 ## 40 24628.18 ## 41 24322.67 ## 42 24246.09 ## 43 24220.49 ## 44 24228.67 ## 45 24721.76 ## 46 24642.88 ## 47 24618.25 ## 48 24626.43 ## 49 24306.33 ## 50 24221.18 ## 51 24192.52 ## 52 24200.71 ## 53 24717.64 ## 54 24640.43 ## 55 24616.10 ## 56 24624.29 ## 57 24323.16 ## 58 24241.00 ## 59 24214.10 ## 60 24222.29 ## 61 24718.68 ## 62 24642.03 ## 63 24617.87 ## 64 24626.05 ## 65 24319.05 ## 66 24238.53 ## 67 24212.20 ## 68 24220.38 ## 69 24717.69 ## 70 24640.51 ## 71 24616.24 ## 72 24624.43 ## 73 24300.79 ## 74 24208.50 ## 75 24177.95 ## 76 24186.14 ## 77 24735.01 ## 78 24657.22 ## 79 24632.71 ## 80 24640.89 ## 81 24316.69 ## 82 24233.27 ## 83 24205.10 ## 84 24213.29 ## 85 24730.89 ## 86 24654.85 ## 87 24630.68 ## 88 24638.86 ## 89 24311.09 ## 90 24220.59 ## 91 24190.78 ## 92 24198.96 phangorn calculates multiple statistics that can be used to judge the fit of all the models. Which one you choose depends on what you prefer, although the field standard is generally to use the Akaike Information Criterion. This is a single number that combines how well the model fits the data (as determined by the log likelihood score) with a penalty for increasing model complexity. More complex models will almost always fit the data better, but in small datasets it can be difficult to get good estimates of every parameter when the model is complex. With AIC, we might find the GTR + G + I model fits the best, but we only have enough samples to estimates 2 parameters with any confidence. In this case, the AIC score might tell us to use the K80 (K2P) model. Smaller numbers are better when it comes to AIC. This is also the case for AICc (which is a “second generation” or updated calculate of AIC) and BIC (the Bayesian Information Criterion, a version of AIC that includes a stronger penalty for additional parameters). In RStudio, you canclick on “mod.test” in the Environment tab from the pane in the upper right corner. That will open the results of our model test analysis in a separate window. If we click on “AIC” or “AICc”, we can order the models by the AIC values. When we do this, we see the lowest AIC and AICc values are for the GTR + G model, which is what we will use going forward. 13.3 Building the neighbor joining tree We’ve already calculated a distance matrix above, but this time we will specify the model we want to use. dist.matrix &lt;- dist.dna(grass.align, model = &quot;GTR + G&quot;) tree &lt;- NJ(dist.matrix) tree But wait, why are we getting an error message? As it turns out, the modelTest command might test 24 different models, but the dist.dna command can’t use all of those models. This is frustrating but also not uncommon when doing phylogenetic analyses. Unfortunately, not every program supports every substitution model. dist.dna appears to support the following models: RAW, JC69, K80, F81, K81, F84, T92, TN93, GG95, LOGDET, BH87, PARALIN, N, TS, TV, INDEL, INDELBLOCK. We can check which of these models has the lowest AIC from our earlier model test. Surprisingly, it’s the K80 model, which is what we used initially. dist.matrix &lt;- dist.dna(grass.align, model = &quot;K80&quot;) tree &lt;- NJ(dist.matrix) 13.4 Visualizing the neighbor joining tree Let’s take a look at the neighbor joining tree. plot(tree, type = &quot;unrooted&quot;) While we have indeed generated a tree, it’s not really the easiest to interpret at the moment. It’s hard to see what the relationships among taxa are because the tips are labeled with GenBank accession numbers instead of taxa names. Also, we really ought to declare an outgroup. First let’s change the tip labels. This is simply a matter of replacing each accession number with the taxon name. We do this by creating a vector of taxon names (matching the order of the accession numbers), then replacing the tip.label variable in our tree object. Because most of us are not plant experts, we’ll use the common names for each sample, but it’s also acceptable to use the scientific names. tree$tip.label ## [1] &quot;JX915632&quot; &quot;EF105403.1&quot; &quot;DQ073553.1&quot; &quot;FJ481575.1&quot; &quot;EF204545.1&quot; ## [6] &quot;AJ314771.1&quot; &quot;FJ481569.1&quot; &quot;DQ073533.1&quot; &quot;AY804128.1&quot; &quot;AY303125.2&quot; ## [11] &quot;KF887414.1&quot; &quot;D82941.1&quot; &quot;JX276655.1&quot; new.labels &lt;- c(&#39;wheat&#39;, &#39;intermediate wheatgrass&#39;, &#39;mammoth wild rye&#39;, &#39;wheatgrass&#39;, &#39;tall wheatgrass&#39;, &#39;rye&#39;, &#39;Asiatic grass&#39;, &#39;crested wheatgrass&#39;, &#39;Tauschs goatgrass&#39;, &#39;medusahead rye&#39;, &#39;mosquito grass&#39;, &#39;barley_D-hordein&#39;, &#39;Siberian wild rye_D-hordein&#39; ) tree$tip.label &lt;- new.labels Next, we declare our outgroup (in this case, the two D-hordein samples) and root our tree. (Remember, we did this in our first exercise using R.) tree.root &lt;- root(tree, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) plot(tree.root, type = &quot;phylogram&quot;, main = &#39;Neighbor Joining, Glu-1&#39;) Now we have a tree that we can begin to make sense of. To an non-botanist, it seems interesting the samples with the common name “wheatgrass” don’t appear to be clustering together. Common names can be misleading about phylogenetic relationships! 13.5 Saving your trees You want to be sure to save the rooted tree and model test results to the persistent disk. write.tree(tree.root, file = &#39;nj_grass.tre&#39;) write.table(mod.test, file = &#39;grass_model_test&#39;, quote=F, sep=&#39;\\t&#39;) sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] phangorn_2.11.1 DECIPHER_2.30.0 RSQLite_2.3.5 ## [4] Biostrings_2.70.3 GenomeInfoDb_1.38.8 XVector_0.42.0 ## [7] IRanges_2.36.0 S4Vectors_0.40.2 BiocGenerics_0.48.1 ## [10] ape_5.7-1 ## ## loaded via a namespace (and not attached): ## [1] fastmatch_1.1-4 xfun_0.48 bslib_0.6.1 ## [4] websocket_1.4.2 processx_3.8.3 lattice_0.21-9 ## [7] tzdb_0.4.0 quadprog_1.5-8 vctrs_0.6.5 ## [10] tools_4.3.2 ps_1.7.6 bitops_1.0-9 ## [13] generics_0.1.3 tibble_3.2.1 fansi_1.0.6 ## [16] highr_0.11 blob_1.2.4 pkgconfig_2.0.3 ## [19] Matrix_1.6-1.1 lifecycle_1.0.4 GenomeInfoDbData_1.2.11 ## [22] compiler_4.3.2 stringr_1.5.1 chromote_0.3.1 ## [25] janitor_2.2.0 codetools_0.2-19 snakecase_0.11.1 ## [28] htmltools_0.5.7 sass_0.4.8 RCurl_1.98-1.14 ## [31] yaml_2.3.8 crayon_1.5.2 later_1.3.2 ## [34] pillar_1.9.0 jquerylib_0.1.4 openssl_2.1.1 ## [37] cachem_1.0.8 nlme_3.1-164 webshot2_0.1.1 ## [40] tidyselect_1.2.0 ottrpal_1.3.0 digest_0.6.34 ## [43] stringi_1.8.3 dplyr_1.1.4 bookdown_0.41 ## [46] rprojroot_2.0.4 fastmap_1.1.1 grid_4.3.2 ## [49] cli_3.6.2 magrittr_2.0.3 utf8_1.2.4 ## [52] readr_2.1.5 promises_1.2.1 bit64_4.0.5 ## [55] lubridate_1.9.3 timechange_0.3.0 rmarkdown_2.25 ## [58] httr_1.4.7 igraph_2.0.2 bit_4.0.5 ## [61] askpass_1.2.0 hms_1.1.3 memoise_2.0.1 ## [64] evaluate_0.23 knitr_1.48 rlang_1.1.4 ## [67] Rcpp_1.0.12 DBI_1.2.2 glue_1.7.0 ## [70] xml2_1.3.6 jsonlite_1.8.8 R6_2.5.1 ## [73] zlibbioc_1.48.2 "],["the-parsimony-method-of-tree-estimation.html", "Chapter 14 The parsimony method of tree estimation 14.1 Parsimony 14.2 Tree searching methods", " Chapter 14 The parsimony method of tree estimation This week we begin examining the tree-searching methods of tree estimation. Specifically, we will focus on the parsimony method. 14.1 Parsimony Parsimony operates on the assumption that the tree containing the fewest sequence changes is the most accurate estimation of what really occurred. Essentially, parsimony assumes that characteristics shared by taxa are shared as the result of common ancestry. Sometimes this assumption is not valid, but often it is, particularly when there is not too much homoplasy (when two or more sequences or structures resemble each other but don’t have a common ancestral origin) or variation in rates between sites. Often there will be multiple equally parsimonious trees, in which case you can either make a consensus tree (a combination of all the equally parsimoniously trees), or pick one tree that is illustrative of the point being discussed. If you choose the second, make sure you mention the existence of the other, equally parsimonious trees! Parsimony is technically not a phylogenetic method because it does not apply a substitution model to the sequence data. A proper parsimony tree does not scale the branches to the number of changes between taxa. Instead, all the taxa are lined up and the branches are however long they need to be in order for the taxa to line up. We will be scaling the branches in our parsimony trees to reflect the number of changes along each branch, so we will not be working with the parsimony method in its purest form. The parsimony method is the backbone of the field known as “cladistics.” It’s largely fallen out of favor as phylogenetics is much more suited to analyzing genetic data. Parsimony still survives as a method of choice for researchers at the American Museum of Natural History and among paleontologists (or anyone who is inferring trees based on non-genetic data). The battle between cladistics proponents and phylogenetics proponents was so intense during the 1980s and 1990s my undergraduate advisor jokingly referred to it as the Clade Wars. 14.2 Tree searching methods At the heart of the parsimony approach is the idea of tree searching. The parsimony algorithm starts with a random tree (sometimes even a neighbor joining tree, or a tree the researcher supplies). The starting tree is scored, then the tree topology is rearranged in some way to create a new tree. The new tree is scored; if its score is better than the previous tree, the new tree is kept. The process then continues until an optimum tree score is found or it reaches a set end point. When a tree has only a small number of taxa, an exhaustive search of all possible topologies is possible. However, the number of possible topologies grows exponentially as the number of taxa increases (in his Phylogenetic Trees Made Easy manual, Barry G. Hall estimates that for a tree with just 10 taxa, there are more than 34 million possible rooted topologies). It rapidly becomes impractical to perform an exhaustive topology search to find the best tree. Instead, researchers have developed tree-searching algorithms to more quickly sort through all the possibilities. 14.2.1 Branch and bound The branch and bound method, while not exhaustive, can still be time-consuming when dealing with more than ~10 taxa. In this approach, an initial random tree of all the taxa is created and scored.Then, the algorithm starts with a tree containing three taxa. Next, a branch containing a fourth taxon is inserted in all possible locations and each possible tree is scored. If none of the possible trees scores better than the initial random tree, this particular search is abandoned and a new starting tree of 3 taxa is created. If, however, any of these possible trees has a score smaller than the score of the initial random tree, the search continues and a fifth taxon is added. The process is repeated, with one change - if none of the trees with five taxa score low enough, then the search goes back to the four taxa tree and tries a different fifth taxon. This way, the initial work isn’t wasted. 14.2.2 Nearest Neighbor Interchange (NNI) Nearest neighbor interchange algorithms take advantage of the fact that there are only three possible ways to connect four groups. A random starting tree is divided into four parts (or subtrees). These four subtrees are connected in all three possible ways. The most parsimonious arrangement is kept, and the new tree is then randomly subdivided into four new subtrees so the process can start again. 14.2.3 Subtree Pruning and Regrafting (SPR) Subtree pruning and regrafting has two major steps. First, a random subtree is removed from the original starting tree; then, the subtree is inserted elsewhere on the main tree to create a new node. This rearranged tree is scored. If if is more parsimonious than the starting tree, the new tree is kept, and another subtree is pruned and regrafted. 14.2.4 Star decomposition We actually saw the star decomposition method in the neighbor joining section. All taxa are connected together at a single node to form a star tree. Next, a pair of taxa are joined to form a new node and the tree is scored. This is repeated until all possible pairs have been evaluated. The best is kept and then another pair of taxa are joined, and the process continues. "],["building-a-parsimony-tree.html", "Chapter 15 Building a parsimony tree 15.1 Editing the fasta file 15.2 Inferring a parsimony tree 15.3 Parsimony scores 15.4 Bootstrapping 15.5 Saving files", " Chapter 15 Building a parsimony tree We will continue using the phangorn package for our parsimony analyses. We are also going to briefly use the phytools package to modify the fasta file. The manual for the phytools package is here. install.packages(&#39;phylotools&#39;) library(phylotools) library(phangorn) 15.1 Editing the fasta file Last week we edited the tip labels of our neighbor joining tree so that the tree displayed the common names of our grass samples instead of the GenBank accession numbers. However, we’re going to be building multiple trees from the grass fasta file, so it makes sense to edit the fasta file directly so we don’t have to manually change the tip labels every time. Phytools allows us to edit fasta files using the rename.fasta command. Before we can use it, though, we need to create a dataframe with two columns: the first column contains the old sample names (the GenBank accession numbers), while the second column contains the new sample names (the common names for each sample). A dataframe in R is a table or a two-dimensional array-like structure in which each column contains values of one variable and each row contains one set of values from each column. We can create one by binding (or pasting) two vectors together. The vectors we are binding MUST have the information in the same order (that is, the order of GenBank accession numbers must be the same order as the common names). old.labels &lt;- c(&quot;JX915632&quot;, &quot;EF105403.1&quot;, &quot;DQ073553.1&quot;, &quot;FJ481575.1&quot;, &quot;EF204545.1&quot;,&quot;AJ314771.1&quot;, &quot;FJ481569.1&quot;, &quot;DQ073533.1&quot;, &quot;AY804128.1&quot;, &quot;AY303125.2&quot;, &quot;KF887414.1&quot;, &quot;D82941.1&quot;, &quot;JX276655.1&quot;) new.labels &lt;- c(&#39;wheat&#39;, &#39;intermediate wheatgrass&#39;, &#39;mammoth wild rye&#39;, &#39;wheatgrass&#39;, &#39;tall wheatgrass&#39;, &#39;rye&#39;, &#39;Asiatic grass&#39;, &#39;crested wheatgrass&#39;, &#39;Tauschs goatgrass&#39;, &#39;medusahead rye&#39;, &#39;mosquito grass&#39;, &#39;barley_D-hordein&#39;, &#39;Siberian wild rye_D-hordein&#39; ) sample.df &lt;- cbind(old.labels, new.labels) sample.df ## old.labels new.labels ## [1,] &quot;JX915632&quot; &quot;wheat&quot; ## [2,] &quot;EF105403.1&quot; &quot;intermediate wheatgrass&quot; ## [3,] &quot;DQ073553.1&quot; &quot;mammoth wild rye&quot; ## [4,] &quot;FJ481575.1&quot; &quot;wheatgrass&quot; ## [5,] &quot;EF204545.1&quot; &quot;tall wheatgrass&quot; ## [6,] &quot;AJ314771.1&quot; &quot;rye&quot; ## [7,] &quot;FJ481569.1&quot; &quot;Asiatic grass&quot; ## [8,] &quot;DQ073533.1&quot; &quot;crested wheatgrass&quot; ## [9,] &quot;AY804128.1&quot; &quot;Tauschs goatgrass&quot; ## [10,] &quot;AY303125.2&quot; &quot;medusahead rye&quot; ## [11,] &quot;KF887414.1&quot; &quot;mosquito grass&quot; ## [12,] &quot;D82941.1&quot; &quot;barley_D-hordein&quot; ## [13,] &quot;JX276655.1&quot; &quot;Siberian wild rye_D-hordein&quot; In the dataframe sample.df, you can see that each row is a sample, with the accession number in column 1 and the common name in column 2. We can now use the rename.fasta command. This command requires three arguments. The first is the fasta file that is being edited, the second is the dataframe that contains both the old and new names, and the third is the name for the newly edited fasta file. The new fasta file will be saved in your working directory (on AnVIL, this is the persistent disk). rename.fasta(&#39;grass_aligned.fasta&#39;, sample.df, &#39;grass_aligned-renamed.fasta&#39;) ## grass_aligned-renamed.fasta has been saved to /__w/AnVIL_Phylogenetic-Techniques/AnVIL_Phylogenetic-Techniques 15.2 Inferring a parsimony tree There are several options for inferring parsimony trees using phangorn. We can use the branch and bound tree rearrangement method with the bab command, or we can apply the nearest neighbor interchange (NNI) or subtree prunning and regrafting (SPR) approaches with either the optim.parsimony or pratchet (parsimony ratchet) commands. The branch and bound method can be very, very slow if you have more ~10 samples. Let’s take a look at the parsimony tree that results from a branch-and-bound search of the grass fasta file. g.align &lt;- read.phyDat(&quot;grass_aligned-renamed.fasta&quot;, format=&#39;fasta&#39;) bab.tree &lt;- bab(g.align) bab.root &lt;- root(bab.tree, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) plot(bab.tree, main = &#39;Parsimony, BAB&#39;) To test both NNI and SPR approaches for parsimony trees, we will use the pratchet command. This particular command has lots of possible parameters we can change. maxit: maximum number of iterations minit: minimum number of iterations k: number of rounds of no improvement after which the ratchet is stopped rearrangements: SPR or NNI rearrangements trace: how much information to print after each iteration all: whether to return all equally parsimonius trees, or just one The parsimony ratchet is an approach that was developed by KC Nixon in 1999. This approach is a more efficient way to find better trees than by just NNI or SPR rearrangements alone. phangorn implements it this way: Create a bootstrapped dataset from the original dataset (more on bootstrapping later). Take the current best tree (or starting tree, for the first go-round) and perform tree rearrangements using the bootstrapped dataset, saving the best bootstrap tree. Use the best bootstrap tree and perform tree rearrangements using the original dataset. Compare the parsimony score (the smallest number of changes necessary to describe the data for a given tree) of the bootstrapped tree and the original best tree. Whichever tree is best (ie, has the lowest parsimony score) is then saved as the new “best” tree. This process is repeated until either the algorithm reaches the max number of iterations or the k number is reached. tree.SPR &lt;- pratchet(g.align, maxit = 10000, minit = 100, k = 10, all = T, rearrangements = &#39;SPR&#39;, trace = 0) tree.NNI &lt;- pratchet(g.align, maxit = 10000, minit = 100, k = 10, all = T, rearrangements = &#39;NNI&#39;, trace = 0) #We assign branch lengths to the tree equal to the number of changes tree.SPR &lt;- acctran(tree.SPR, g.align) tree.NNI &lt;- acctran(tree.NNI, g.align) SPR.root &lt;- root(tree.SPR, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) NNI.root &lt;- root(tree.NNI, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) plot(SPR.root, main = &#39;Parsimony, SPR&#39;) plot(NNI.root, main = &#39;Parsimony, NNI&#39;) Take a look at the topology of the trees created using the branch-and-bound (BAB), SPR, and NNI approaches. Do you see any differences? 15.3 Parsimony scores We can compare parsimony trees directly by comparing their parsimony scores. As mentioned above, the parsimony score is just the minimum number of changes necessary to map a dataset onto a particular tree topology. A smaller number is better. tree.SPR &lt;- pratchet(g.align, maxit = 10000, minit = 100, k = 10, all = T, rearrangements = &#39;SPR&#39;, trace = 0) tree.NNI &lt;- pratchet(g.align, maxit = 10000, minit = 100, k = 10, all = T, rearrangements = &#39;NNI&#39;, trace = 0) #We assign branch lengths to the tree equal to the number of changes tree.SPR &lt;- acctran(tree.SPR, g.align) tree.NNI &lt;- acctran(tree.NNI, g.align) SPR.root &lt;- root(tree.SPR, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) NNI.root &lt;- root(tree.NNI, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) #for each parsimony command, we need to provide a tree and a phyDat object parsimony(bab.root, g.align) ## [1] 1624 parsimony(SPR.root, g.align) ## [1] 1624 parsimony(NNI.root, g.align) ## [1] 1624 In the case of our grass dataset, all the parsimony scores are the same, so all of the methods performed equally well. We got lucky - this is not always true! 15.4 Bootstrapping It would be nice to have a way to measure the robustness of each individual branch and clade, not just the overall tree. In phylogenetics, the measurement of choice for determining the “strength” of a branch is the bootstrap value. Bootstrapping is a resampling method that attempts to use the original data as a way to judge the strength of phylogenetic inference. For each bootstrap replicate, the program will randomly select a number of sites to create a pseudoalignment. (For example, if the original alignment has 100 bases, the bootstrap algorithm will randomly choose 100 bases to create a new alignment. Some bases might be chosen multiple times, while other bases don’t get sampled.) After generating the pseudoalignment, a new tree is built and the relationships are stored. Here is a nice illustration of the process by www.analyticsvidhya.com After all the bootstrapping replicates have been analyzed, each branch of the actual tree will be labeled with a value that reflects how frequently that branch was seen among the replicate trees. Higher values mean the branch has more support. In general, researchers consider a branch with a bootstrap value &gt; 0.5 as well-supported. Luckily, the pratchet command automatically does bootstrapping, so we already have the bootstrap information saved. We can see the bootstrap values on the trees using the plotBS command. plotBS(SPR.root, type = &quot;p&quot;, main = &#39;Parsimony, SPR&#39;) plotBS(NNI.root, type = &quot;p&quot;, main = &#39;Parsimony, NNI&#39;) You may need to resize the Plots window in order to more easily read the bootstrap values for each branch. can we bootstrap our neighbor joining tree? In short, yes, although we have to do a bit of R trickery, because neither ape nor phangorn have the option to bootstrap neighbor joining trees built in. We can get around this by writing our own function. Basically, we will write a function that creates a distance matrix using the dist.ml command. (This command is a more general form of the dist.dna command. As of this writing, using dist.dna in the function throws an error.) Then we can include both a phyDat object and our function in the bootstrap.phyDat command. R will take the phyDat object and pass it to our function, then use the distance matrix in a bootstrap analysis. fun &lt;- function(x) nj(dist.ml(x)) bs_nj &lt;- bootstrap.phyDat(g.align, fun) dna_dist &lt;- dist.ml(g.align, model = &#39;JC&#39;) nj.tre &lt;- nj(dna_dist) nj.root &lt;- root(nj.tre, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) plotBS(nj.root, bs_nj, &#39;p&#39;, main = &#39;Neighbor Joining&#39;) This isn’t a perfect approach - for one thing, we can’t use the K80 substitution model for the dist.ml command. Instead, we simply used the JC model. Also, the bootstrapping values in this approach are from 1 to 100, not 0 to 1 as calculated by the pratchet command. How does the bootstrap support for the neighbor joining tree compare to the bootstrap support for the parsimony trees? 15.5 Saving files Make sure to save at least one of the trees you built using the pratchet command to the persistent disk. write.tree(SPR.root, file = &#39;spr_grass.tre&#39;) write.tree(NNI.root, file = &#39;nni_grass.tre&#39;) sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] phangorn_2.11.1 phylotools_0.2.2 ape_5.7-1 ## ## loaded via a namespace (and not attached): ## [1] sass_0.4.8 utf8_1.2.4 generics_0.1.3 xml2_1.3.6 ## [5] lattice_0.21-9 stringi_1.8.3 hms_1.1.3 digest_0.6.34 ## [9] magrittr_2.0.3 grid_4.3.2 evaluate_0.23 timechange_0.3.0 ## [13] bookdown_0.41 fastmap_1.1.1 Matrix_1.6-1.1 rprojroot_2.0.4 ## [17] jsonlite_1.8.8 processx_3.8.3 chromote_0.3.1 ps_1.7.6 ## [21] promises_1.2.1 httr_1.4.7 fansi_1.0.6 ottrpal_1.3.0 ## [25] codetools_0.2-19 jquerylib_0.1.4 cli_3.6.2 rlang_1.1.4 ## [29] cachem_1.0.8 yaml_2.3.8 parallel_4.3.2 tools_4.3.2 ## [33] tzdb_0.4.0 dplyr_1.1.4 fastmatch_1.1-4 vctrs_0.6.5 ## [37] R6_2.5.1 lifecycle_1.0.4 lubridate_1.9.3 snakecase_0.11.1 ## [41] stringr_1.5.1 janitor_2.2.0 pkgconfig_2.0.3 pillar_1.9.0 ## [45] bslib_0.6.1 later_1.3.2 glue_1.7.0 Rcpp_1.0.12 ## [49] highr_0.11 xfun_0.48 tibble_3.2.1 tidyselect_1.2.0 ## [53] knitr_1.48 igraph_2.0.2 nlme_3.1-164 htmltools_0.5.7 ## [57] websocket_1.4.2 rmarkdown_2.25 webshot2_0.1.1 readr_2.1.5 ## [61] compiler_4.3.2 quadprog_1.5-8 askpass_1.2.0 openssl_2.1.1 "],["more-phylogenetics-basics.html", "Chapter 16 More Phylogenetics Basics 16.1 Tree topology 16.2 Outgroups 16.3 Comparing trees", " Chapter 16 More Phylogenetics Basics Now that you’ve had a chance to build several phylogenies, let’s spend some time examining what the trees are telling us. 16.1 Tree topology In an earlier chapter, we talked about nodes and clades. As a reminder, a node is the place where two branches connect. Each node represents a hypothesized most recent common ancestor of the taxa on the tips of the branches. In this tree (the grass neighbor joining tree), the node marked in purple connects all the ingroup samples. (The ingroup for this tree are all grass Glu-1 samples.) We can assume the most recent common ancestor (MRCA) of the ingroup would have existed at this node. The ingroup here is a an example of monophyly; a monophyletic clade is a clade that contains all the descendants of a particular ancestor. There are two other terms that describe clades you might run across. Paraphyly describes a group that contains some (but not all) of the descendants of a node; in the figure above, the highlighted clade is paraphyletic with respect to the node marked with a purple dot. Polyphyly describes a group that contains both descendants and non-descendants of a node. In the grass example, the paraphyletic group contains both the outgroup taxa and a subset of the ingroup. 16.2 Outgroups The choice of the two outgroup taxa (Siberian wild rye D-hordein and barley D-hordein) turned out to be a good decision for the grass tree. First, these two taxa are monophyletic compared to the other samples (that is, they share a recent common ancestor, and the ingroup is monophyletic compared to them). Second, the branch lengths for the two outgroup taxa is similar to the branch lengths of all the ingroup taxa. If the branch lengths for the outgroup taxa are too long, the relationships among all the grass Glu-1 samples will be obscured. However, what if our first outgroup choice hadn’t been quite right? In that case, we could edit the fasta file to remove any samples that we needed. Let’s pretend the outgroup wasn’t monophyletic and that instead the Siberian wild rye D-hordein sample actually fell within the ingroup. In this case, we could simply remove that sample using the phylotools package. library(phylotools) rm.sequence.fasta(infile = &quot;grass_aligned-renamed.fasta&quot;, outfile = &quot;sequence.removed.fasta&quot;, to.rm = &quot;Siberian wild rye_D-hordein&quot;) ## sequence.removed.fasta has been saved to /__w/AnVIL_Phylogenetic-Techniques/AnVIL_Phylogenetic-Techniques We can then load the new fasta file and estimate a new neighbor joining tree (or any other type of tree) without the problematic sample. library(phangorn) grass.new &lt;- read.dna(&quot;sequence.removed.fasta&quot;, format=&#39;fasta&#39;) dist.matrix &lt;- dist.dna(grass.new, model = &quot;K80&quot;) tree &lt;- NJ(dist.matrix) tree.root &lt;- root(tree, outgroup = &#39;barley_D-hordein&#39;) plot(tree.root, main = &quot;edited Neighbor Joining&quot;) You can use the same command to remove multiple outgroup taxa, or to remove an outgroup that is too distant (ie, the branch lengths are too long and including the outgroup is obscuring the relationships among the ingroup samples). If you need to remove all of your outgroup, you can instead try midpoint rooting. rm.sequence.fasta(infile = &quot;grass_aligned-renamed.fasta&quot;, outfile = &quot;no_outgroup.fasta&quot;, to.rm = c(&quot;barley_D-hordein&quot;, &quot;Siberian wild rye_D-hordein&quot;)) ## no_outgroup.fasta has been saved to /__w/AnVIL_Phylogenetic-Techniques/AnVIL_Phylogenetic-Techniques grass.no_out&lt;- read.dna(&quot;no_outgroup.fasta&quot;, format=&#39;fasta&#39;) dist.matrix &lt;- dist.dna(grass.no_out, model = &quot;K80&quot;) tree.no_out &lt;- NJ(dist.matrix) tree.no_out &lt;- midpoint(tree.no_out) plot(tree.no_out, main = &quot;Neighbor Joining, midpoint rooting&quot;) 16.3 Comparing trees When we are trying to determine if two trees are telling us the same thing about the relationships among our samples (that is, the topologies of the two trees are identical), we might compare the descendants of each node. If the descendants of each node are the same, then we know the topologies are the same (even if the order of the clades are not identical - remember, branches can rotate around nodes). We’ll use the grass phylogenies as an example First, we can see that node 1 (the node that connects all the ingroup branches) exists in both trees. The same is true for the node that connects Asiatic grass to the crested wheatgrass/mosquito grass/medusahead rye clade, as well as the nodes resolving the relationships among that that clade. Moving to the bottom of the tree, we can also locate nodes 5, 6, and 7 in both trees. Each of these nodes connects all the same descendants in each tree. Finally, we can identify the presence of nodes 8, 9, and 10 in both trees. This is a little trickier to see, because the branches have rotated. But we can find a node that unites wheat, mammoth wild rye, and intermediate wheatgrass (node 8) as well as a node that unites only mammoth wild rye and intermediate wheatgrass (node 9). We also have a separate node that unites wheatgrass and tall wheatgrass (node 10). Since all of the ingroup nodes are the same, we know the topologies of the neighbor joining and parsimony trees are the same. However, it’s a bit tedious to go through and label each node. Luckily, we can use R to compare topologies more quickly. Open the ape library and load your saved trees into the console. library(ape) nj.tree &lt;- read.tree(&quot;nj_grass.tre&quot;) spr.tree &lt;- read.tree(&quot;spr_grass.tre&quot;) nni.tree &lt;- read.tree(&quot;nni_grass.tre&quot;) The ape package has a very useful all.equal command (you can see more details about it here). This command allows us to compare topologies. all.equal(spr.tree, nj.tree, use.edge.length = F) ## [1] TRUE The first two arguments are the trees we’d like to compare. In order to compare just the topologies, we also include the argument use.edge.length=F, which tells the all.equal command to ignore branch lengths. If we want to tell whether trees are completely identical (that is, both the topologies and the branch lengths are the same), we can change the last argument to T. (Alternatively, we could leave the last argument off entirely, as the default setting is for use.edge.length is T.) all.equal(spr.tree, nj.tree, use.edge.length = T) ## [1] FALSE Not surprisingly, the branch lengths differ between the neighbor joining and SPR parsimony tree. However, maybe the branch lengths are the same between the two trees we estimated using parsimony. all.equal(spr.tree, nni.tree) ## [1] FALSE Well, now we know the two parsimony trees aren’t completely identical. However, what if this is because the topologies aren’t the same? all.equal(spr.tree, nni.tree, use.edge.length = F) ## [1] TRUE By running the all.equal command again, we can verify the topologies are the same, so these two trees must differ in just the branch length estimates. sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] phangorn_2.11.1 phylotools_0.2.2 ape_5.7-1 ## ## loaded via a namespace (and not attached): ## [1] sass_0.4.8 utf8_1.2.4 generics_0.1.3 xml2_1.3.6 ## [5] lattice_0.21-9 stringi_1.8.3 hms_1.1.3 digest_0.6.34 ## [9] magrittr_2.0.3 grid_4.3.2 evaluate_0.23 timechange_0.3.0 ## [13] bookdown_0.41 fastmap_1.1.1 Matrix_1.6-1.1 rprojroot_2.0.4 ## [17] jsonlite_1.8.8 processx_3.8.3 chromote_0.3.1 ps_1.7.6 ## [21] promises_1.2.1 httr_1.4.7 fansi_1.0.6 ottrpal_1.3.0 ## [25] codetools_0.2-19 jquerylib_0.1.4 cli_3.6.2 rlang_1.1.4 ## [29] cachem_1.0.8 yaml_2.3.8 parallel_4.3.2 tools_4.3.2 ## [33] tzdb_0.4.0 dplyr_1.1.4 fastmatch_1.1-4 vctrs_0.6.5 ## [37] R6_2.5.1 lifecycle_1.0.4 lubridate_1.9.3 snakecase_0.11.1 ## [41] stringr_1.5.1 janitor_2.2.0 pkgconfig_2.0.3 pillar_1.9.0 ## [45] bslib_0.6.1 later_1.3.2 glue_1.7.0 Rcpp_1.0.12 ## [49] highr_0.11 xfun_0.48 tibble_3.2.1 tidyselect_1.2.0 ## [53] knitr_1.48 igraph_2.0.2 nlme_3.1-164 htmltools_0.5.7 ## [57] websocket_1.4.2 rmarkdown_2.25 webshot2_0.1.1 readr_2.1.5 ## [61] compiler_4.3.2 quadprog_1.5-8 askpass_1.2.0 openssl_2.1.1 "],["what-is-maximum-likelihood.html", "Chapter 17 What is Maximum Likelihood?", " Chapter 17 What is Maximum Likelihood? We are finally ready to try estimating trees using a true phylogenetic method. Maximum likelihood is a tree-searching method that attempts to find a tree that maximizes the likelihood of observing the data. Put another way, we want a tree that makes the data we see likely. If you’ve ever done any sort of statistical test (like a linear regression or a chi-square test), you’ve been doing maximum likelihood tests. Essentially, for each possible DNA mutation you’ve seen in the data, you are finding a tree that recreates the most likely pattern of mutation that you see in your data. This includes limiting the amount of homoplasy or mutational reversals. Maximum likelihood searches are tree-based searches (like parsimony). You supply a starting tree, and the algorithm estimates the likelihood of that tree given the data. (The likelihood value is often very small, so we transform it using to the loglikelihood for ease.) Then the algorithm permutates (or changes) the tree and calculates the likelihood of the new tree. If the new tree has a better likelihood, then it is kept and another permutation is tried. If the likelihood of the new tree is worse than the original tree, then the new tree is discarded and the algorithm tries a different permutation on the old tree. The advent of the maximum likelihood method (published by Joe Felsenstein in 1981) revolutionized the field of evolutionary biology and really kickstarted the creation of phylogenetics as it exists today. "],["estimating-a-tree-using-maximum-likelihood.html", "Chapter 18 Estimating a tree using Maximum Likelihood 18.1 Creating a starting tree 18.2 Calculating likelihood score 18.3 Optimizing the maximum likelihood parameters 18.4 Changing the model for your ML search 18.5 Bootstrapping the ML tree 18.6 Saving your bootstrap tree", " Chapter 18 Estimating a tree using Maximum Likelihood We will be using the phangorn package in R to estimate maximum likelihood methods. phangorn has three possible tree permutation methods available in its maximum likelihood commands. The first is the nearest neighbor interchange (NNI) method, which we used in our parsimony estimation. However, the NNI algorithm can sometimes get stuck on a local optimum in tree space (especially as the tree gets larger). The other two (the stochastic approach and the likelihood ratchet) will make random NNI rearrangements to the tree, which can allow the tree to escape local optima and instead find a global optimum of our tree-searching space. 18.1 Creating a starting tree phangorn requires a starting tree for maximum likelihood searches. The tree itself doesn’t matter much, but generally people supply a neighbor joining tree because they can be generated quickly. library(phangorn) grass.align &lt;- read.phyDat(&quot;grass_aligned-renamed.fasta&quot;, format = &quot;fasta&quot;) dist &lt;- dist.ml(grass.align) nj.tree &lt;- nj(dist) You can also upload your previously-generated neighbor joining tree and use that instead of creating a new one (just make sure that you used the same sample names in both your renamed fasta file and your neighbor joining tree). nj.tree &lt;- read.tree(&quot;nj.tre&quot;) 18.2 Calculating likelihood score Once you have both a tree and your fasta file loaded, you can calculated a likelihood score using the pml command. fit &lt;- pml(nj.tree, data = grass.align) fit ## model: JC ## loglikelihood: -12533.76 ## unconstrained loglikelihood: -20944.97 ## ## Rate matrix: ## a c g t ## a 0 1 1 1 ## c 1 0 1 1 ## g 1 1 0 1 ## t 1 1 1 0 ## ## Base frequencies: ## a c g t ## 0.25 0.25 0.25 0.25 One of the nice things about the pml output is that it includes the details of the substitution model used in the likelihood calculation. In this case, because we did not specify any model, the Jukes-Cantor (JC, or JC69) was used by default. We can tell this because the base frequencies are all 0.25 and there is only one substitution rate used in the rate matrix. This output also reports both a log likelihood and an unconstrained log likelihood. The difference between the two values has to do with the size of the parameter space being searched. In my experience, the log likelihood (not the unconstrained log likelihood) is usually reported, though either is fine as long as you are consistent when testing multiple models. 18.3 Optimizing the maximum likelihood parameters The pml command simply calculates the likelihood of the data, given a tree. If we want to find the optimum tree (and we do), we need to optimize the tree topology (as well as branch length estimates) for our data. We can do this using the optim.pml command. For this particular model (JC), we simply need to supply a pml object (which we created above) and decide what type of tree arrangement we want to do. fitJC &lt;- optim.pml(fit, rearrangement = &quot;NNI&quot;) ## optimize edge weights: -12533.76 --&gt; -12487.58 ## optimize edge weights: -12487.58 --&gt; -12487.58 ## optimize topology: -12487.58 --&gt; -12466.62 NNI moves: 2 ## optimize edge weights: -12466.62 --&gt; -12466.62 ## optimize topology: -12466.62 --&gt; -12466.62 NNI moves: 0 plot(fitJC$tree, main = &quot;JC, NNI rearrangement&quot;) With the choice of NNI rearrangement, you can see that only a few moves were necessary in order to find the ML tree. We can also choose a “stochastic” or “ratchet” (likelihood ratchet) tree rearrangement algorithm. I like to use the stochastic rearrangement. Using either the stochastic or ratchet tree rearrangement takes more time than NNI. Here I’ve also added a command to hide the output while the algorithm is running, but feel free to leave it off so you can see what the algorithm is doing! fitJC &lt;- optim.pml(fit, rearrangement = &quot;stochastic&quot;, control = pml.control(trace = 0)) plot(fitJC$tree, main = &quot;JC, stochastic rearrangement&quot;) 18.4 Changing the model for your ML search All the work above is for the Jukes-Cantor model. However, there is a whole world of other substition models out there, and it would be nice to use them as well. We can update the pml object “fit” with other models. According to the model test we ran on the grass data in the Neighbor Joining section, the best model for this dataset is the GTR + G model. The gamma distribution has two parameters, a shape parameter and a scale parameter. In phylogenetics, we commonly think of these as the number of rate categories and a shape parameter. When adding a gamma distribution, we can just specify the number of rate categories to start. The standard is 4. fitGTR.G &lt;- update(fit, model = &quot;GTR&quot;, k = 4) fitGTR.G ## model: GTR+G(4) ## loglikelihood: -12503.04 ## unconstrained loglikelihood: -20944.97 ## Discrete gamma model ## Number of rate categories: 4 ## Shape parameter: 1 ## ## Rate matrix: ## a c g t ## a 0 1 1 1 ## c 1 0 1 1 ## g 1 1 0 1 ## t 1 1 1 0 ## ## Base frequencies: ## a c g t ## 0.25 0.25 0.25 0.25 After we update the model and add the gamma distribution, we can see that fitGTR now 4 rate categories and a shape parameter = 1. However, the rate matrix and base frequencies are still the same as the JC model, because we did not update those. We could if we wanted to, but it’s easier to let the optim.pml algorithm do it. fitGTR.G &lt;- optim.pml(fitGTR.G, model = &quot;GTR&quot;, optGamma = T, rearrangement = &quot;stochastic&quot;, control = pml.control(trace = 0)) fitGTR.G ## model: GTR+G(4) ## loglikelihood: -11945.78 ## unconstrained loglikelihood: -20944.97 ## Discrete gamma model ## Number of rate categories: 4 ## Shape parameter: 1.19688 ## ## Rate matrix: ## a c g t ## a 0.0000000 0.4378420 1.6826685 0.7665308 ## c 0.4378420 0.0000000 0.4612309 2.7050199 ## g 1.6826685 0.4612309 0.0000000 1.0000000 ## t 0.7665308 2.7050199 1.0000000 0.0000000 ## ## Base frequencies: ## a c g t ## 0.3196529 0.2974113 0.2592177 0.1237181 plot(fitGTR.G$tree, main = &quot;GTR + G&quot;) We can also update the model to include an invariant sites parameter (inv = 0.2). fitGTR.G.I &lt;- update(fitGTR.G, inv = 0.2) fitGTR.G.I &lt;- optim.pml(fitGTR.G.I, model = &quot;GTR&quot;, optGamma = T, optInv = T, rearrangement = &quot;stochastic&quot;, control = pml.control(trace = 0)) fitGTR.G.I ## model: GTR+G(4)+I ## loglikelihood: -11945.78 ## unconstrained loglikelihood: -20944.97 ## Proportion of invariant sites: 5.218644e-05 ## Discrete gamma model ## Number of rate categories: 4 ## Shape parameter: 1.196526 ## ## Rate matrix: ## a c g t ## a 0.0000000 0.4369734 1.6803296 0.7652394 ## c 0.4369734 0.0000000 0.4602445 2.7015575 ## g 1.6803296 0.4602445 0.0000000 1.0000000 ## t 0.7652394 2.7015575 1.0000000 0.0000000 ## ## Base frequencies: ## a c g t ## 0.3196556 0.2974835 0.2591984 0.1236624 plot(fitGTR.G.I$tree, main = &quot;GTR + I + G&quot;) Keep in mind that we never want to overwrite our original “fit” object. By updating the “fit” object (and saving the update by a new name), we can easily go back and change the model for our ML estimation. Let’s try a K80 (Kimura 2-parameter) model with an invariant sites parameter. In the optim.pml command, we can leave out the optGamma = T argument because we no longer have a gamma distribution included in the model. fitK80.I &lt;- update(fit, model = &quot;K80&quot;, inv = 0.2) fitK80.I &lt;- optim.pml(fitK80.I, model = &quot;K80&quot;, optInv = T, rearrangement = &quot;stochastic&quot;, control = pml.control(trace = 0)) fitK80.I ## model: K80+I ## loglikelihood: -12195.32 ## unconstrained loglikelihood: -20944.97 ## Proportion of invariant sites: 0.2632001 ## ## Rate matrix: ## a c g t ## a 0.000000 1.000000 3.275521 1.000000 ## c 1.000000 0.000000 1.000000 3.275521 ## g 3.275521 1.000000 0.000000 1.000000 ## t 1.000000 3.275521 1.000000 0.000000 ## ## Base frequencies: ## a c g t ## 0.25 0.25 0.25 0.25 plot(fitK80.I$tree, main = &quot;K80 + I&quot;) 18.5 Bootstrapping the ML tree Once we have decided which ML tree fits the data best (we can do so by choosing the one with the biggest log likelihood value), we can estimate the support for each branch in the tree with bootstrapping. Bootstrapping for ML trees can be very, very slow, so be patient! Ideally we want to do at least 1000 bootstrap replicates. Many guides will set the number of bootstrap replicates to 100, but this is often chosen for speed. We really need at least 1000 replicates to have any sort of trust in the values. We will use the bootstrap.pml command, which does have an option to estimate trees in parallel, which can help speed up the bootstrapping process. This option doesn’t appear to work on Windows machines, but it works fine on AnVIL. Using AnVIL itself will also help speed up the estimation. Let’s try bootstrapping the GTR + G tree, which was the model chosen for us using the modelTest command. bs &lt;- bootstrap.pml(fitGTR.G, bs=1000, multicore = T, optNni=TRUE, + control = pml.control(trace = 0)) bs &lt;- bootstrap.pml(fitGTR.G, bs=100, optNni=TRUE, control = pml.control(trace = 0)) To plot the bootstrap values, we can use a special plot function called plotBS. First, however, we need to root the tree. Then we can plot the rooted tree with our bootstrap values (saved in a list called “bs”), We are also going to format the bootstrap values so that only those values greater than 0.5 (50% bootstrap support) are shown using the p argument. We can also decide what color to make the bootstrap values and how many decimal places we want to see. (For a semi-complete list of colors in R, look here.) tree.root &lt;- root(fitGTR.G$tree, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) plotBS(tree.root, bs, main = &quot;GTR + G bootstrap&quot;, type = &quot;p&quot;, bs.col=&quot;orange&quot;, p = 0.5, digits = 2) 18.6 Saving your bootstrap tree Before you end your session, make sure to save your trees to your persistent disk. write.tree(fitGTR.G$tree, file=&quot;grass_ml.tre&quot;) write.tree(bs, file=&quot;grass_ml_bootstrap.tre&quot;) sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] phangorn_2.11.1 ape_5.7-1 ## ## loaded via a namespace (and not attached): ## [1] sass_0.4.8 utf8_1.2.4 generics_0.1.3 xml2_1.3.6 ## [5] lattice_0.21-9 stringi_1.8.3 hms_1.1.3 digest_0.6.34 ## [9] magrittr_2.0.3 grid_4.3.2 evaluate_0.23 timechange_0.3.0 ## [13] bookdown_0.41 fastmap_1.1.1 Matrix_1.6-1.1 rprojroot_2.0.4 ## [17] jsonlite_1.8.8 processx_3.8.3 chromote_0.3.1 ps_1.7.6 ## [21] promises_1.2.1 httr_1.4.7 fansi_1.0.6 ottrpal_1.3.0 ## [25] codetools_0.2-19 jquerylib_0.1.4 cli_3.6.2 rlang_1.1.4 ## [29] cachem_1.0.8 yaml_2.3.8 parallel_4.3.2 tools_4.3.2 ## [33] tzdb_0.4.0 dplyr_1.1.4 fastmatch_1.1-4 vctrs_0.6.5 ## [37] R6_2.5.1 lifecycle_1.0.4 lubridate_1.9.3 snakecase_0.11.1 ## [41] stringr_1.5.1 janitor_2.2.0 pkgconfig_2.0.3 pillar_1.9.0 ## [45] bslib_0.6.1 later_1.3.2 glue_1.7.0 Rcpp_1.0.12 ## [49] highr_0.11 xfun_0.48 tibble_3.2.1 tidyselect_1.2.0 ## [53] knitr_1.48 igraph_2.0.2 nlme_3.1-164 htmltools_0.5.7 ## [57] websocket_1.4.2 rmarkdown_2.25 webshot2_0.1.1 readr_2.1.5 ## [61] compiler_4.3.2 quadprog_1.5-8 askpass_1.2.0 openssl_2.1.1 "],["what-is-a-time-tree.html", "Chapter 19 What is a time tree? 19.1 Molecular clocks 19.2 Calibration points", " Chapter 19 What is a time tree? We’re tackling the topic of time trees, which are basically phylogenetic trees where the branches have been scaled to show time since divergence. Short branches mean very little time has passed since the most recent common ancestor, while longer branches mean a long time has passed. Without realizing it, you have probably looked at trees you’ve built earlier in the class and assumed the branches indicate time as well as the number of mutations or changes seen in your alignment. This is really only true when the branches have been scaled. Absolute time trees, which are trees whose branches have been scaled based on a known calibration point, have been considered controversial in the past, though they’ve gained acceptance in the past ten years. Relative time trees (trees that have been scaled relative to the root of the tree, although the age of the root is unknown) were accepted fairly quickly, particularly when dealing with closely-related species. 19.1 Molecular clocks What makes time trees possible are the use of a molecular clock. This is the idea that DNA mutations happen in a fairly regular fashion that we can describe and simulate using mathematical models. The simplest version of a clock is to take the number of differences between two species and divide them by the time since they diverged. The resulting number is mu, or the mutation rate. In 1963, Emanuel Margoliash introduced the genetic equidistance idea, writing: “It appears that the number of residue differences between cytochrome c of any two species is mostly conditioned by the time elapsed since the lines of evolution leading to these two species originally diverged. If this is correct, the cytochrome c of all mammals should be equally different from the cytochrome c of all birds. Since fish diverges from the main stem of vertebrate evolution earlier than either birds or mammals, the cytochrome c of both mammals and birds should be equally different from the cytochrome c of fish. Similarly, all vertebrate cytochrome c should be equally different from the yeast protein.” Not all trees show clocklike patterns. In some cases, the number of mutations is much greater on a branch due to selection pressure. In other cases, very long branches will appear to stop developing new mutations due to saturation (sites are changing more than once, but we can only detect one change). Recent work has developed new clock models to get around these issues. A molecular clock can only say how long tree branches are relative to each other, but cannot estimate actual ages of nodes or times to most recent common ancestors (MRCA). In order to do that, you need to apply calibration points. 19.2 Calibration points Calibration points are phylogenetic splits which researchers have managed to date with some accuracy. There are three major sources for calibration dates: the fossil record, geologic events, and independent molecular data. The fossil record can be used to estimate the latest point at which a split might have occurred and is considered the gold standard of calibration methods. However, not everything can be captured by the fossil record, so we rely on other methods to fill in the missing spaces. Geologic events are quite useful when working with species that are endemic (or exclusively found) to a location like volcanic islands. A geologic split estimate is the earliest possible date for a split to have occurred. One of the most famous geologic event used for dating is the formation of the Hawaiian islands. We have fairly firm dates for when each of the islands arose, so we can date with some certainty the date when species arrived on each island. Independent molecular data calibration is the only source of calibration for many taxa, but dates estimated using this approach also have the greatest uncertainty, as they are indirectly based on either fossil record or geologic event dating of related taxa. "],["adding-calibration-points-to-your-phylogenies.html", "Chapter 20 Adding calibration points to your phylogenies 20.1 Choosing calibration points 20.2 Adding calibration points to internal nodes for ML trees 20.3 Adding calibration points for Bayesian trees 20.4 Visualizing the time trees in FigTree", " Chapter 20 Adding calibration points to your phylogenies This week we will be working with both RStudio and BEAST. Within RStudio, we will be using the ape package again. 20.1 Choosing calibration points This week, you should choose at least one calibration point to add to your tree. You can pick any two taxa from a tree and figure out the estimated age of the divergence between them (or the estimated age of the most recent common ancestor between them). The website TimeTree has divergence estimates for many different taxa pairs. When two taxa (usually species, but it could be taxa from higher taxonomic levels) are entered into TimeTree, the website first checks whether these taxa are in the TimeTree of Life database. If they are, the divergence estimate between the two (the age of the MRCA between them) is retrieved. If one or both of the taxa are not in the database, the website scans NCBI taxonomy to find the closest relative of the species and uses that as a proxy to find the MRCA for two taxa. If your taxa are not on TimeTree, you will have to be creative in finding a calibration point. You might be able to find information in the literature. If you are working with viral samples, you can use the date the sample was collected as a tip calibration point. If nothing works and you are stuck, email me and I will send you the grass dataset to work with. For the grass dataset, let’s use the divergence between bread wheat (Triticum aestivum) and crested wheatgrass (Agropyron cristatum). When we search TimeTree, we see several estimated divergence times. TimeTree gives us two divergence estimates: a median estimate (with 95% confidence interval), and an adjusted time, which is quite a bit older than the median estimate. This is what TimeTree says about their adjusted time estimate: “Answer: Due to conflicting time estimates between studies, ancestral nodes can be assigned younger ages than their descendants. A smoothing technique is used to adjust these times so the resulting tree is ultrametric.” (An ultrametric tree is one where all the a rooted tree with edge lengths where all leaves are equidistant from the root. When trees have been scaled using calibration points, they often become ultrametric.) In this case, the very youngest divergence estimate from TimeTree is 2.6 million years ago (MYA), while the oldest is 16.5 MYA. We will use these estimates going forward. We could have easily chosen the other estimates as well. There isn’t necessarily a right or wrong choice here. You just need to be upfront about the estimates you chose. 20.2 Adding calibration points to internal nodes for ML trees When we look at the grass tree, we see the node that indicates the MRCA between crested wheatgrass and bread wheat (labeled wheat on the tree) is pretty deep within the tree. If we trace the branches until we find the node where they connect, we can see it is the basal node of the tree (the node which connects the ingroup to the outgroup). In order to add a calibration date to our ML tree in R, we need to know how R has identified (or labeled) that particular node. You can either load your saved ML tree or create it again. library(ape) library(phangorn) grass.align &lt;- read.phyDat(&quot;grass_aligned-renamed.fasta&quot;, format = &quot;fasta&quot;) dist &lt;- dist.ml(grass.align) nj.tree &lt;- nj(dist) fit &lt;- pml(nj.tree, data = grass.align) fitGTR.G &lt;- update(fit, model = &quot;GTR&quot;, k = 4) fitGTR.G &lt;- optim.pml(fitGTR.G, model = &quot;GTR&quot;, optGamma = T, rearrangement = &quot;stochastic&quot;, control = pml.control(trace = 0)) tree.root &lt;- root(fitGTR.G$tree, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) plot(tree.root) nodelabels() The node that connects crested wheatgrass and wheat (and indicates the MRCA between the two) is node 21. We will use that information, as well as the estimated divergence times from TimeTree, to apply a timescale to the ML tree using the chronos command from the ape package. If you’d like to read more about it, the ape manual is here. The chronos command takes several arguments. The first is a lambda starting estimate (the smoothing parameter). The next argument is the model of rate substitution variation (how much should the mutation rate vary among the branches of the tree?). chronos can implement a strict clock (no variation, called “clock”), a correlated clock (where the variation is correlated between branches, but does exist, called “correlated”), a discrete clock (where estimates are discrete for each branch and requires multiple estimated parameters, called “discrete”), or a relaxed clock. The relaxed clock (called “relaxed”) allows for discrete mutation rates on the branches, but doesn’t involve estimating a different parameter for each branch. We’ll implement the discrete clock in this example. (The estimation is fairly quick, so you can easily implement all four and see how the resulting trees differ.) The remaining arguments is the calibration data frame (which includes the actual calibration points). We use the command makeChronosCalib command to create the calibration data frame. This command takes the ML tree as the first argument. calib &lt;- makeChronosCalib(tree.root, node = 21, age.min = 2.6, age.max = 16.5) calib ## node age.min age.max soft.bounds ## 1 21 2.6 16.5 FALSE If we want to add more calibration points, we can use the c (concatenate) command. This tells R that a string of multiple entries are being entered at once. calib2 &lt;- makeChronosCalib(tree.root, node = c(&quot;21&quot;, &quot;19&quot;), age.min = c(2.6,3.0), age.max = c(16.5, 16.5)) calib2 ## node age.min age.max soft.bounds ## 1 21 2.6 16.5 FALSE ## 2 19 3.0 16.5 FALSE Creating the time tree, we simply combine the chronos and makeChronosCalib commands. time.tree &lt;- as.phylo(tree.root) time.tree_dated &lt;- chronos(time.tree, lambda = 1, model = &quot;discrete&quot;, quiet = FALSE, calibration = calib, control = chronos.control()) ## ## Setting initial dates... ## Fitting in progress... get a first set of estimates ## (Penalised) log-lik = -3.840593 ## Optimising rates... frequencies... dates... -3.840593 ## Optimising rates... frequencies... dates... -3.542538 ## ## log-Lik = -3.542538 ## PHIIC = 67.09 Before we plot the tree, we need to do a bit of formatting of the branch lengths (called edge.length). R will be default save these values to 10 decimal places, which can make visualization a little tricky. We’re going to format them so they only have two decimal places, then plot them on top of the time tree. time.tree_dated$edge.length &lt;- round(time.tree_dated$edge.length, digits = 2) plot(time.tree_dated) edgelabels(time.tree_dated$edge.length, bg=&quot;black&quot;, col=&quot;white&quot;, font=2) Behold, you have a time tree. The branch lengths are now scaled to million of years, so you can estimate the age of MRCA between any two taxa on the tree. For example, based on the discrete clock model, our tree suggests the MRCA between mosquito grass and medusahead rye lived ~11 MYA (the length of the branch between mosquito grass and the node that denotes the common ancestor with medusahead rye). Before you end your session, make sure you save your tree (and then download the .tre file to your desktop). write.tree(time.tree_dated, &quot;ml_grass_timetree.tre&quot;) 20.3 Adding calibration points for Bayesian trees We can add calibration points using the BEAUTi gui you worked with last week. In this case, we open BEAUTi and load our dataset. We have two choices at this point: we can choose the “Tip Dates” tab and specify the date each sample was taken (useful for viral trees, especially during an outbreak), or we can choose the “Clock Model” tab (if you do this, use a strict clock model unless you are certain your data are not clock-like). If you’ve chosen to not use Tip Dates, we will add additional calibration points in the “Priors” tab. These instructions are taken from the tutorial you worked with last week. The rest of your parameters (including your substitution model and priors) can be set to the same values you used last week. Follow the instructions from last week to get your final Bayesian tree. 20.4 Visualizing the time trees in FigTree After you finish creating your trees, you can visualize both the ML and Bayesian tree using FigTree. Play around with the options to make the tree look nice - I recommend making the tip labels larger. Be sure to include your branch lengths! Those are now scaled to be the divergence times for both the ML and Bayesian trees. sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] phangorn_2.11.1 ape_5.7-1 ## ## loaded via a namespace (and not attached): ## [1] sass_0.4.8 utf8_1.2.4 generics_0.1.3 xml2_1.3.6 ## [5] lattice_0.21-9 stringi_1.8.3 hms_1.1.3 digest_0.6.34 ## [9] magrittr_2.0.3 grid_4.3.2 evaluate_0.23 timechange_0.3.0 ## [13] bookdown_0.41 fastmap_1.1.1 Matrix_1.6-1.1 rprojroot_2.0.4 ## [17] jsonlite_1.8.8 processx_3.8.3 chromote_0.3.1 ps_1.7.6 ## [21] promises_1.2.1 httr_1.4.7 fansi_1.0.6 ottrpal_1.3.0 ## [25] codetools_0.2-19 jquerylib_0.1.4 cli_3.6.2 rlang_1.1.4 ## [29] cachem_1.0.8 yaml_2.3.8 parallel_4.3.2 tools_4.3.2 ## [33] tzdb_0.4.0 dplyr_1.1.4 fastmatch_1.1-4 vctrs_0.6.5 ## [37] R6_2.5.1 lifecycle_1.0.4 lubridate_1.9.3 snakecase_0.11.1 ## [41] stringr_1.5.1 janitor_2.2.0 pkgconfig_2.0.3 pillar_1.9.0 ## [45] bslib_0.6.1 later_1.3.2 glue_1.7.0 Rcpp_1.0.12 ## [49] highr_0.11 xfun_0.48 tibble_3.2.1 tidyselect_1.2.0 ## [53] knitr_1.48 igraph_2.0.2 nlme_3.1-164 htmltools_0.5.7 ## [57] websocket_1.4.2 rmarkdown_2.25 webshot2_0.1.1 readr_2.1.5 ## [61] compiler_4.3.2 quadprog_1.5-8 askpass_1.2.0 openssl_2.1.1 "],["what-is-a-network.html", "Chapter 21 What is a network? 21.1 Why do we see competing phylogenetic relationships?", " Chapter 21 What is a network? Phylogenetic networks (sometimes called the splits network) are a way to examine conflicting phylogenetic relationships in your data. Like a tree, networks visually represent evolutionary relationships among taxa. Unlike a tree, a network can show conflicting signals in the data, when multiple relationship patterns are supported. (A tree will simply show the relationship with the most data support.) These types of analyses started gaining in popularity with the advent of big data in the mid 2000s, because researchers were discovering that not all genes within an organism had the same evolutionary history. Phenomena such as incomplete lineage sorting, gene loss or duplication, hybridization, or horizontal gene transfer mean that genes in an organism’s genome can come from a variety of sources. Our simple understanding of speciation (a population splits in two, and the resulting daughter populations become genetically isolated from each other and develop into two new, different species) was no longer sufficient to describe what actually happens in nature. This is the essential idea behind the difference between gene trees and species trees. Take a look at this figure (Daniel Huson, ISMB-Tutorial 2007: Introduction to Phylogenetic Networks) Figure T1 and T2 represent possible phylogenetic relationships among taxa. Let’s say 60% the data support the relationship in T1, while the other 40% of the data support the relationship in T2. If we were to use all the data together to infer a single consensus tree, we would only see the relationships in T1; the information in T2 would be completely obscured. A phylogenetic network, on the other hand, will show us both possible relationships (the diamond shape you see in the third figure). It’s as if figure T1 was overlaid on figure T2 (with some extra branches drawn). In a network, the diamond shapes represent all the different possible phylogenetic relationships. 21.1 Why do we see competing phylogenetic relationships? The process of speciation is slow. While it sounds straightforward (a population splits into two reproductively isolated daughter populations, which then become two new species), in reality it is a very slow and messy process. Sometimes we are examining taxa that have only recently become separate. In this situation, we might be seeing the result of incomplete lineage sorting. When populations first split, there will be individuals within each daughter population who have the same allele for particular genes or genomic regions. Usually these shared alleles will sort, or become extinct in one population but not the other. However, this process takes time, and the bigger the daughter population, the longer this process takes. If the two daughter populations have been separated long enough for genomic sorting to have occurred, the conflicting phylogenetic relationships could be the result of introgression. Among sexually reproductive species, members of two separate species might interbreed or hybridize (this is very common in some orders, especially ducks!). In bacteria, genes can be transferred between bacteria of different species via horizontal gene transfer. Viruses will also swap entire genes in a similar process. Finally, it may not be possible to reconstruct the phylogenetic relationships among groups if speciation happened over a very short time period (similar to what you expect in an adaptive radiation). In this case, the relationships among species might look like a polytomy instead of a series of bifurcating nodes. Gene trees and species trees One of the most important things to remember in phylogenetics is that we estimate gene trees. We often use these as proxies for species trees, but they are not the same thing. Due to the process of sorting and introgression, the phylogenetic relationships supported by a certain percentage of genes or genomic regions will actually differ from the species tree. When you are looking at trees built with data from only one gene, you can’t guarantee that your gene tree is reflective of the species tree! This is problematic now that we’re using whole genomes to infer phylogenies. The methods we use for inferring phylogenies were designed based on the idea that all the sequences evolved following a single model of evolution, with no complicating factors like lateral gene transfer, duplication events, or recombination. Unfortunately, the genome is a wild hodgepodge of coding regions, noncoding regions, introns, exons, regulatory regions, pseudogenes, and a bunch of other things we probably don’t know about yet. Each of these regions may have their own evolutionary history that is best modeled by a variety of molecular models. There are two basic approaches to dealing with the whole genome mess. Both of these approaches are computationally complex and generally can only be done with neighbor joining or parsimony methods, at least for now. Researchers can consider each genomic region separately (the consensus gene tree approach), and then find an evolutionary history that best fits the distribution of topologies generated by each separate genomic region. Alternatively, researchers can “glue” the whole genome together into a single fasta file (the concatenation approach), which they then use for analysis, assuming you can figure out how to align the genomes. Gene duplication, gene deletion, and the presense of pseudogene regions make this a not-insignificant problem. When you are working with microbial genomes, you have the added difficulty of the pan-genome problem. In many bacteria, genes can generally be sorted into two groups: the core genes (genes that are present in all members of a species) and the accessory genes (genes that can be present, but don’t have to be). The collection of all core genes plus all accessory genes is called the pan-genome. A typical S. aureus genome is about 2800 genes (1000 core genes and 1800 accessory genes). Unfortunately, the S. aureus pan-genome is a little more than 7400 genes. That means the 1800 accessory genes in any given S. aureus genome are selected from 6400 possibilities. This should not discourage you from the possibility of building whole genome phylogenetic trees. New methods and programs are coming out all the time to deal with these problems, and trees from whole genome sequence are becoming a reality. If this is something you’re interested in, take a look at programs like kSNP3. "],["visualizing-phylogenetic-networks.html", "Chapter 22 Visualizing phylogenetic networks 22.1 Using DensiTree 22.2 Networks in R", " Chapter 22 Visualizing phylogenetic networks We will be working with both the DensiTree application from BEAST and the phangorn package in R. 22.1 Using DensiTree When you ran your Bayesian analysis, you created a distribution of trees. You summarized this distribution when you looked at the posterior estimates of support for the nodes and clades, but there is a lot more information we can get from this distribution. Open DensiTree on your personal computer. (DensiTree should have been installed when you downloaded BEAST.) Click on File, then Load and choose your .trees file that was created when you ran BEAST. All the trees in the distribution will be drawn in a fuzzy-looking tree. The darker the line, the more consensus there is among your tree distribution that the branch exists. In the grass example, we see branches in three separate colors - blue, orange, and green. (I changed the default colors by clicking on “Line Color” in the menu on the right side of the screen. If you open it and then open the “Line Colors” option, you can change your colors as well.) The blue branches are branches supported by the majority of the tree distribution, while the orange and green branches represent alternate branching patterns. The orange and green colors are very light because those alternate branching patterns show up in only a small percentage of the tree distribution. We can see the percentage if we click on “Help” and then “View Clades.” There’s not much disagreement among the trees in the posterior distribution for our grass example. The main disagreement is with the placement of the Asiatic grass sample; 85% of the trees place Asiatic grass with the crested wheatgrass/medusahead rye/mosquito grass clade, which 15% place it in a different position. I have been using the words “probability” and “percentage” interchangeably when talking about the Bayesian posterior tree distribution. Although probability and percentage aren’t usually the same thing, in this case they are. We are estimating the probability of topologies by calculating the percentage of the tree distribution with the desired topology. 22.2 Networks in R phangorn offers an algorithm called consensusNet to visualize conflicting topological relationships from our data. This algorithm builds networks similar to the Huson example above using previously-generated analyses files. We have two options for our input. consensusNet takes a list of trees as the input (which R sees an an object of class multiPhylo), so we can either load the bootstrap trees from the ML analysis or the posterior distribution of trees from the Bayesian analysis. Here we will do both with the grass dataset so we can compare the networks. (Notice that we need to use two different commands to load the trees into R - the two tree files are saved in two separate formats. The ML trees are saved in Newick format, while the Bayesian trees are saved in Nexus format.) library(phangorn) grass.ml &lt;- read.tree(&quot;grass_ml_bootstrap.tre&quot;) grass.bayes &lt;- read.nexus(&quot;grass_bayes.trees&quot;) After we load our trees, we run the consensusNet command. This command takes two arguments. The first is the tree file, while the second is the bootstrap value threshold. For this example, we’ll set the threshold at 0.1, meaning we will see all the possible nodes with at least a bootstrap support or posterior density of 0.1. cnet.ml &lt;- consensusNet(grass.ml, .1) cnet.bayes &lt;- consensusNet(grass.bayes, .1) plot(cnet.ml, show.edge.label=TRUE) We can see there are very few alternate topologies in the bootstrap trees (which we already knew would be the case, given the high bootstrap support in the original ML tree!), but there are a couple of splits. The first suggests that crested wheatgrass is sometimes in a polytomy with medusahead rye and mosquito grass, instead of splitting from that clade earlier. The second split suggests that some trees has Asiatic grass splitting from the main tree as the basal node and sometimes clusters with the crested wheatgrass/medusahead rye/mosquito grass clade. Finally, the last split changes the position of rye. plot(cnet.bayes, show.edge.label=TRUE) There is only one split in the Bayesian network - the placement of Asiatic grass taxon. We have seen this already in the DensiTree diagram, but it does look a bit different in network form. This particular split shows up in both the ML bootstrap network and the Bayesian posterior distribution network. We can also add the support values for each split (the bootstrap values for the ML network, or the posterior probabilities for the Bayesian network) by changing the show.edge.label command to equal TRUE. Be careful, though, as this can make the network very difficult to read. sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] phangorn_2.11.1 ape_5.7-1 ## ## loaded via a namespace (and not attached): ## [1] sass_0.4.8 utf8_1.2.4 generics_0.1.3 xml2_1.3.6 ## [5] lattice_0.21-9 stringi_1.8.3 hms_1.1.3 digest_0.6.34 ## [9] magrittr_2.0.3 grid_4.3.2 evaluate_0.23 timechange_0.3.0 ## [13] bookdown_0.41 fastmap_1.1.1 Matrix_1.6-1.1 rprojroot_2.0.4 ## [17] jsonlite_1.8.8 processx_3.8.3 chromote_0.3.1 ps_1.7.6 ## [21] promises_1.2.1 httr_1.4.7 fansi_1.0.6 ottrpal_1.3.0 ## [25] codetools_0.2-19 jquerylib_0.1.4 cli_3.6.2 rlang_1.1.4 ## [29] cachem_1.0.8 yaml_2.3.8 parallel_4.3.2 tools_4.3.2 ## [33] tzdb_0.4.0 dplyr_1.1.4 fastmatch_1.1-4 vctrs_0.6.5 ## [37] R6_2.5.1 lifecycle_1.0.4 lubridate_1.9.3 snakecase_0.11.1 ## [41] stringr_1.5.1 janitor_2.2.0 pkgconfig_2.0.3 pillar_1.9.0 ## [45] bslib_0.6.1 later_1.3.2 glue_1.7.0 Rcpp_1.0.12 ## [49] xfun_0.48 tibble_3.2.1 tidyselect_1.2.0 knitr_1.48 ## [53] igraph_2.0.2 nlme_3.1-164 htmltools_0.5.7 websocket_1.4.2 ## [57] rmarkdown_2.25 webshot2_0.1.1 readr_2.1.5 compiler_4.3.2 ## [61] quadprog_1.5-8 askpass_1.2.0 openssl_2.1.1 "],["ancestral-state-reconstruction.html", "Chapter 23 Ancestral state reconstruction 23.1 Reconstructing ancestral sequences 23.2 Reconstructing ancestral continuous phenotypes 23.3 Reconstructing ancestral discrete phenotypes", " Chapter 23 Ancestral state reconstruction For some studies, building a phylogenetic tree is just the beginning. The researchers are more interested in using their phylogenetic tree to test other hypotheses about evolution. One of the most common of these is ancestral state reconstruction, or identifying the state of a trait in a common ancestor of a clade. Researchers might be interested in the ancestral nucleotide at a particular part of as sequence (especially a coding sequence), or they might be curious about the ancestral phenotype or behavior. Ancestral state reconstruction analyses can be done using tools in the phangorn and phytools libraries in R. 23.1 Reconstructing ancestral sequences Let’s start by reconstructing putative ancestral sequences at the nodes within our grass tree. We will use both the phangorn and phylotools packages. We need both the fasta file and an ML tree. I’ve chosen to recreate the ML tree instead of loading my saved tree directly becausee R has reformatted the taxa names slightly in the grass tree. If this has not happened to you, you can load your ML tree directly using the read.tree command instead of rerunning the analysis. #install.packages(&#39;phytools&#39;) library(phangorn) library(phylotools) grass.align &lt;- read.phyDat(&quot;grass_aligned-renamed.fasta&quot;, format = &quot;fasta&quot;) dist &lt;- dist.ml(grass.align) nj.tree &lt;- nj(dist) fit &lt;- pml(nj.tree, data = grass.align) fitGTR.G &lt;- update(fit, model = &quot;GTR&quot;, k = 4) fitGTR.G &lt;- optim.pml(fitGTR.G, model = &quot;GTR&quot;, optGamma = T, rearrangement = &quot;stochastic&quot;, control = pml.control(trace = 0)) fitGTR.G$tree &lt;- root(fit$tree, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian wild rye_D-hordein&#39;)) plot(fitGTR.G) After we look at the grass tree to make sure it is rooted the way we want, we use the ancestral.pml command to estimate the ancestral sequence for each node. ancestral.pml can run either an ML or Bayesian analysis. This command takes two arguments: the full output of your ML analysis and a choice of either “ml” or “bayes”. We will use ML, but you could just as easily use the Bayesian method. After running the ancestral state reconstruction, we plot the nucleotide at base 209 for each node and tip. (I randomly chose base 209. In practice, researchers likely would have already identified locations of interest.) anc.ml &lt;- ancestral.pml(fitGTR.G, &quot;ml&quot;) plotAnc(fitGTR.G$tree, anc.ml, 209) At base 209, most of the samples and putative most recent common ancestors have a G, although at some point a mutation occurred in the ancestors of the rye/wheatgrass/tall wheatgrass/wheat/mammoth wild rye/intermediate wheatgrass clade, which is why those taxa mostly have an A at base 209. (Rye is clearly the weirdo with a T.) The pie chart for the barley D-hordein sequence shows all four possible bases, which just means this particular base is likely missing in the barley D-hordein sequence (either because it was not sequenced or because there was a deletion event and the base does not exist). Additionally, the pie charts for some ancestral nodes have multiple colors. When estimating ancestral sequences, ancestral.pml is calculating the likelihood of each possible nucleotide. At the nodes with pies containing both green and purple wedges, either an A or a G is possible in the ancestral sequence. The bigger wedge indicates the nucleotide with the greatest likelihood. We could do this for any base, like base 1023 (another one I picked at random). plotAnc(fitGTR.G$tree, anc.ml, 1023) We see a very different pattern of inheritance for base 1023. The vast majority of the samples have an A, so nearly all the reconstructed ancestral sequences also have an A. The exception are the nodes in the crested wheatgrass/mosquito grass/medusahead rye clade. All three of the samples have a different nucleotide (or are missing that base), so the reconstructed sequence for the most recent common ancestors is less certain than in the rest of the tree. 23.2 Reconstructing ancestral continuous phenotypes We can use the phytools package to estimate and visualize the reconstruction of continuous traits. I’ve collected the maximum plant height for most of grass taxa used in the tree, so we can estimate how tall the common ancestors of each clade might have been. First, we install and load the phytools package, then we load our ML tree. #install.packages(&#39;phytools&#39;) library(phytools) g.tree &lt;- read.tree(&#39;grass_ml.tre&#39;) tree.root &lt;- root(g.tree, outgroup = c(&#39;barley_D-hordein&#39;,&#39;Siberian_wild_rye_D-hordein&#39;)) plot(tree.root) This tree has 13 samples, but we aren’t going to use all of them for the grass analysis. First, we want to remove the outgroups (the two D-hordein samples) because in this case their position doesn’t represent the phylogenetic relationships between barley and the ingroup or Siberian wild rye and the ingroup. (They represent the phylogenetic relationship of D-hordein and the Glu sequences instead. If you used the same genetic region/gene for your outgroup, you can leave them in. If I had used Siberian wild rye Glu sequence, it would be fine to leave the outgroup.) I also was unable to find information on the maximum height of Asiatic grass. We can remove these taxa from the tree directly using the drop.tip command. new &lt;- drop.tip(tree.root, c(&#39;barley_D-hordein&#39;, &#39;Siberian_wild_rye_D-hordein&#39;, &#39;Asiatic_grass&#39;), trim.internal = TRUE, subtree = FALSE, root.edge = 0, rooted = is.rooted(tree.root), collapse.singles = TRUE, interactive = FALSE) plot(new) nodelabels() Great! We have a tree with only the taxa we want, and we can also see the label R has assigned to each node. Now we will create a vector containing all the maximum heights (in inches) for each taxa, in the same order as the tree. We can find the proper taxa order by querying the tip.label. new$tip.label ## [1] &quot;intermediate_wheatgrass&quot; &quot;mammoth_wild_rye&quot; ## [3] &quot;medusahead_rye&quot; &quot;mosquito_grass&quot; ## [5] &quot;crested_wheatgrass&quot; &quot;Tauschs_goatgrass&quot; ## [7] &quot;rye&quot; &quot;tall_wheatgrass&quot; ## [9] &quot;wheatgrass&quot; &quot;wheat&quot; height &lt;- as.numeric(c(24, 36, 20, 30, 48, 18, 78, 60, 48, 48)) Now that we have both our tree and our continuous phenotype, we calculate the ancestral phenotype estimates with the fastAnc command. This is an ML method. I have not found a Bayesian approach for ancestral state reconstruction of continuous traits. The arguments for this command are the tree, the vector of the phenotypes, and either “TRUE” or “FALSE” value for calculating the confidence intervals around the likelihood estimate for each node. anc.height &lt;- fastAnc(new, height, CI = TRUE) anc.height ## Ancestral character estimates using fastAnc: ## 11 12 13 14 15 16 17 18 ## 38.86652 39.48086 45.55305 44.79273 36.62223 30.30063 51.11004 37.32842 ## 19 ## 33.42004 ## ## Lower &amp; upper 95% CIs: ## lower upper ## 11 8.611576 69.12146 ## 12 13.092046 65.86967 ## 13 25.436181 65.66992 ## 14 26.220219 63.36524 ## 15 25.882117 47.36233 ## 16 23.346769 37.25449 ## 17 31.765750 70.45434 ## 18 8.662230 65.99461 ## 19 4.092481 62.74760 Although there’s some variation in the maximum height of the various grass samples in this tree, most of the putative common ancestors are estimated to have been between 35 and 40 inches tall. However, when we look at the CIs for these estimates, we find they are quite wide, suggesting a lot of uncertainty about these ancestral height estimates. Perhaps this isn’t the best method for reconstructing this particular trait! The author of phytools has also created a command that allows you to visualize the continuous trait estimates on the tree. Unfortunately, it appears this command doesn’t always work for every tree, possibly due to package updates. If you’re interested, you can learn more about the contMap function. 23.3 Reconstructing ancestral discrete phenotypes We might also be interested in reconstructing ancestral phenotypes for discrete traits. We can also do this in phytools. For this section, I’ve collected information as to whether each grass species in the tree is an annual or a perennial plant. Before we can do the analysis, we need to convert the edited tree from the earlier section to a phylo object, as well as load the phenotypes. The phenotypes can be typed in directly and assigned to a vector as in the previous section, or we can load them from a text file. Here, we load the phenotypes from a textfile that has two columns. The first column is the sample name and the second column is the annual/perennial assignment. This file is tab-delimited. When we load the file into R, we use the row.names command to specify that the first column (the sample names) are set as the row names of our object. We then reformat the first column as a matrix and assign it to the object pheno, which turns pheno into a vector. (Make sure your phenotype file is in the same order as your tip labels!) new &lt;- as.phylo(new) pheno &lt;- read.table(&#39;grass_discrete.txt&#39;, row.names = 1) pheno &lt;- as.matrix(pheno)[,1] pheno ## crested_wheatgrass mosquito_grass medusahead_rye ## &quot;perennial&quot; &quot;perennial&quot; &quot;annual&quot; ## Tauschs_goatgrass rye wheatgrass ## &quot;annual&quot; &quot;annual&quot; &quot;annual&quot; ## tall_wheatgrass wheat mammoth_wild_rye ## &quot;perennial&quot; &quot;annual&quot; &quot;perennial&quot; ## intermediate_wheatgrass ## &quot;perennial&quot; Now we are ready to do the ancestral state reconstruction using the ace command. (ace stands for “ancestral character estimation.”) This command takes four arguments: the phenotype vector, the tree (formatted as a phylo object), the model (which is always set to “ER” for discrete characters), and the character type. This particular estimation uses a Bayesian approach. The ace command technically can do ML estimation according to the manual, but I have not gotten it to work successfully. ## ## Ancestral Character Estimation ## ## Call: ace(x = pheno, phy = new, type = &quot;discrete&quot;, model = &quot;ER&quot;) ## ## Log-likelihood: -6.052494 ## ## Rate index matrix: ## annual perennial ## annual . 1 ## perennial 1 . ## ## Parameter estimates: ## rate index estimate std-err ## 1 67.1331 67.9721 ## ## Scaled likelihoods at the root (type &#39;...$lik.anc&#39; to get them for all nodes): ## annual perennial ## 0.4999752 0.5000248 fit.discrete&lt;-ace(pheno, new, model=&quot;ER&quot;,type=&quot;discrete&quot;) fit.discrete ## ## Ancestral Character Estimation ## ## Call: ace(x = pheno, phy = new, type = &quot;discrete&quot;, model = &quot;ER&quot;) ## ## Log-likelihood: -6.052494 ## ## Rate index matrix: ## annual perennial ## annual . 1 ## perennial 1 . ## ## Parameter estimates: ## rate index estimate std-err ## 1 67.1331 67.9721 ## ## Scaled likelihoods at the root (type &#39;...$lik.anc&#39; to get them for all nodes): ## annual perennial ## 0.4999752 0.5000248 The output for this estimation gives us scaled likelihoods for the ancestral state at the most basal node. We have to specifically request the scaled likelihood estimates for all the nodes. fit.discrete$lik.anc Well, it appears that whether the common ancestors at each node were annuals or perennials is a toss-up. Maybe we can get more insight if we look at the output on a tree. Visualizing this output requires a couple of steps. First, we plot the phylogenetic tree. Then, we define the colors that will correspond to each character state. (The commands are flexible so that you can copy and paste for discrete traits with more than two possible states. I’ve included an alternate way to set the colors, marked with a #.) Finally, we add piecharts at each node and each tip label, then plot the legend. plot(new) cols &lt;- c(&#39;blue&#39;, &#39;orange&#39;) nodelabels(node=1:new$Nnode+Ntip(new),pie=fit.discrete$lik.anc,piecol=cols,cex=0.7) tiplabels(pie=to.matrix(pheno,sort(unique(pheno))),piecol=cols,cex=0.3) add.simmap.legend(colors=cols,prompt=FALSE,x=0.9*par()$usr[1], y=-max(nodeHeights(new)),fsize=0.8) Similarly to what we saw above when we looked at ancestral reconstruction of sequences, each pie chart indicates the posterior probability of each possible character state. In this case, it appears we can’t really tell whether the perennial or annual trait is ancestral. What’s clear is that the derived trait (the one that isn’t ancestral) has popped up multiple times in multiple clades. sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] phytools_2.1-1 maps_3.4.2 phylotools_0.2.2 phangorn_2.11.1 ## [5] ape_5.7-1 ## ## loaded via a namespace (and not attached): ## [1] fastmatch_1.1-4 xfun_0.48 bslib_0.6.1 ## [4] websocket_1.4.2 processx_3.8.3 lattice_0.21-9 ## [7] numDeriv_2016.8-1.1 tzdb_0.4.0 quadprog_1.5-8 ## [10] vctrs_0.6.5 tools_4.3.2 ps_1.7.6 ## [13] generics_0.1.3 parallel_4.3.2 tibble_3.2.1 ## [16] fansi_1.0.6 highr_0.11 pkgconfig_2.0.3 ## [19] Matrix_1.6-1.1 scatterplot3d_0.3-44 lifecycle_1.0.4 ## [22] compiler_4.3.2 stringr_1.5.1 mnormt_2.1.1 ## [25] combinat_0.0-8 chromote_0.3.1 janitor_2.2.0 ## [28] codetools_0.2-19 snakecase_0.11.1 htmltools_0.5.7 ## [31] sass_0.4.8 yaml_2.3.8 later_1.3.2 ## [34] pillar_1.9.0 jquerylib_0.1.4 MASS_7.3-60 ## [37] openssl_2.1.1 cachem_1.0.8 clusterGeneration_1.3.8 ## [40] iterators_1.0.14 foreach_1.5.2 nlme_3.1-164 ## [43] webshot2_0.1.1 tidyselect_1.2.0 ottrpal_1.3.0 ## [46] digest_0.6.34 stringi_1.8.3 dplyr_1.1.4 ## [49] bookdown_0.41 rprojroot_2.0.4 fastmap_1.1.1 ## [52] grid_4.3.2 expm_0.999-9 cli_3.6.2 ## [55] magrittr_2.0.3 optimParallel_1.0-2 utf8_1.2.4 ## [58] readr_2.1.5 promises_1.2.1 lubridate_1.9.3 ## [61] timechange_0.3.0 rmarkdown_2.25 httr_1.4.7 ## [64] igraph_2.0.2 askpass_1.2.0 hms_1.1.3 ## [67] coda_0.19-4.1 evaluate_0.23 knitr_1.48 ## [70] doParallel_1.0.17 rlang_1.1.4 Rcpp_1.0.12 ## [73] glue_1.7.0 xml2_1.3.6 jsonlite_1.8.8 ## [76] R6_2.5.1 "],["about-the-authors.html", "About the Authors", " About the Authors These credits are based on our course contributors table guidelines.     Credits Names Pedagogy Lead Content Instructor Elizabeth Humphries Content Idea Contributor Ava Hoffman, Frederick Tan Content Directors Elizabeth Humphries, Jeff Leek, Frederick Tan Production Content Publisher Ira Gooding Technical Template Publishing Engineers Candace Savonen, Carrie Wright, Ava Hoffman Publishing Maintenance Engineer Candace Savonen Technical Publishing Stylists Carrie Wright, Candace Savonen Package Developers (ottrpal) John Muschelli, Candace Savonen, Carrie Wright Funding Funder National Human Genome Research Institute (NHGRI) Funding Staff Fallon Bachman, Jennifer Vessio, Emily Voeglein   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.3.2 (2023-10-31) ## os Ubuntu 22.04.4 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2025-05-06 ## pandoc 3.1.1 @ /usr/local/bin/ (via rmarkdown) ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date (UTC) lib source ## bookdown 0.41 2024-10-16 [1] CRAN (R 4.3.2) ## bslib 0.6.1 2023-11-28 [1] RSPM (R 4.3.0) ## cachem 1.0.8 2023-05-01 [1] RSPM (R 4.3.0) ## cli 3.6.2 2023-12-11 [1] RSPM (R 4.3.0) ## devtools 2.4.5 2022-10-11 [1] RSPM (R 4.3.0) ## digest 0.6.34 2024-01-11 [1] RSPM (R 4.3.0) ## ellipsis 0.3.2 2021-04-29 [1] RSPM (R 4.3.0) ## evaluate 0.23 2023-11-01 [1] RSPM (R 4.3.0) ## fastmap 1.1.1 2023-02-24 [1] RSPM (R 4.3.0) ## fs 1.6.3 2023-07-20 [1] RSPM (R 4.3.0) ## glue 1.7.0 2024-01-09 [1] RSPM (R 4.3.0) ## htmltools 0.5.7 2023-11-03 [1] RSPM (R 4.3.0) ## htmlwidgets 1.6.4 2023-12-06 [1] RSPM (R 4.3.0) ## httpuv 1.6.14 2024-01-26 [1] RSPM (R 4.3.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.3.0) ## jsonlite 1.8.8 2023-12-04 [1] RSPM (R 4.3.0) ## knitr 1.48 2024-07-07 [1] CRAN (R 4.3.2) ## later 1.3.2 2023-12-06 [1] RSPM (R 4.3.0) ## lifecycle 1.0.4 2023-11-07 [1] RSPM (R 4.3.0) ## magrittr 2.0.3 2022-03-30 [1] RSPM (R 4.3.0) ## memoise 2.0.1 2021-11-26 [1] RSPM (R 4.3.0) ## mime 0.12 2021-09-28 [1] RSPM (R 4.3.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.3.0) ## pkgbuild 1.4.3 2023-12-10 [1] RSPM (R 4.3.0) ## pkgload 1.3.4 2024-01-16 [1] RSPM (R 4.3.0) ## profvis 0.3.8 2023-05-02 [1] RSPM (R 4.3.0) ## promises 1.2.1 2023-08-10 [1] RSPM (R 4.3.0) ## purrr 1.0.2 2023-08-10 [1] RSPM (R 4.3.0) ## R6 2.5.1 2021-08-19 [1] RSPM (R 4.3.0) ## Rcpp 1.0.12 2024-01-09 [1] RSPM (R 4.3.0) ## remotes 2.4.2.1 2023-07-18 [1] RSPM (R 4.3.0) ## rlang 1.1.4 2024-06-04 [1] CRAN (R 4.3.2) ## rmarkdown 2.25 2023-09-18 [1] RSPM (R 4.3.0) ## sass 0.4.8 2023-12-06 [1] RSPM (R 4.3.0) ## sessioninfo 1.2.2 2021-12-06 [1] RSPM (R 4.3.0) ## shiny 1.8.0 2023-11-17 [1] RSPM (R 4.3.0) ## stringi 1.8.3 2023-12-11 [1] RSPM (R 4.3.0) ## stringr 1.5.1 2023-11-14 [1] RSPM (R 4.3.0) ## urlchecker 1.0.1 2021-11-30 [1] RSPM (R 4.3.0) ## usethis 2.2.3 2024-02-19 [1] RSPM (R 4.3.0) ## vctrs 0.6.5 2023-12-01 [1] RSPM (R 4.3.0) ## xfun 0.48 2024-10-03 [1] CRAN (R 4.3.2) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.3.0) ## yaml 2.3.8 2023-12-11 [1] RSPM (R 4.3.0) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library ## ## ────────────────────────────────────────────────────────────────────────────── 2022 GitHub, Inc. Terms Privacy Security Status Doc "],["references.html", "Chapter 24 References", " Chapter 24 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
